---
title: "M√©todo de Punto Fijo"
author: "Proyecto Personal - Ingenier√≠a en Computaci√≥n"  
date: today
format: 
  html:
    theme: cosmo
    code-fold: true
    toc: true
    number-sections: true
    highlight-style: github
    fig-width: 10
    fig-height: 6
    embed-resources: true
execute:
  warning: false
  echo: true
---

# ¬øPara qu√© sirve?

El m√©todo de punto fijo es una t√©cnica iterativa fundamental para resolver ecuaciones no lineales de la forma $f(x) = 0$. Su principal ventaja es la simplicidad conceptual y computacional, convirti√©ndolo en una herramienta valiosa en diversas aplicaciones:

## Aplicaciones Pr√°cticas

- **An√°lisis de estabilidad en sistemas din√°micos**: Encontrar puntos de equilibrio
- **Econom√≠a**: Modelado de equilibrios de mercado y puntos de saturaci√≥n
- **Ingenier√≠a**: An√°lisis de circuitos no lineales y sistemas de control
- **F√≠sica**: Determinaci√≥n de estados estacionarios en sistemas f√≠sicos
- **Matem√°tica aplicada**: Resoluci√≥n de ecuaciones integrales y diferenciales

## Casos de Uso Espec√≠ficos

1. **Ecuaciones transcendentales**: Como $x = \cos(x)$ o $x = e^{-x}$
2. **Sistemas de retroalimentaci√≥n**: Donde la salida depende de la entrada de forma no lineal
3. **Modelos poblacionales**: Puntos de equilibrio en crecimiento log√≠stico
4. **An√°lisis de convergencia**: Estudio del comportamiento iterativo de funciones

# ¬øC√≥mo funciona?

## Fundamento Te√≥rico

El m√©todo transforma la ecuaci√≥n $f(x) = 0$ en una ecuaci√≥n equivalente $x = g(x)$, donde $g(x)$ es una funci√≥n de iteraci√≥n. El proceso consiste en:

1. **Transformaci√≥n**: Convertir $f(x) = 0$ a $x = g(x)$
2. **Iteraci√≥n**: Aplicar repetidamente $x_{n+1} = g(x_n)$
3. **Convergencia**: Cuando $|x_{n+1} - x_n| < \varepsilon$

## Algoritmo Paso a Paso

```
1. INICIO
2. Definir f(x) = 0 y transformar a x = g(x)
3. Establecer x‚ÇÄ (valor inicial)
4. Establecer tolerancia Œµ y m√°ximo de iteraciones N
5. Para n = 0, 1, 2, ..., N:
   a. Calcular x_{n+1} = g(x_n)
   b. Verificar convergencia: |x_{n+1} - x_n| < Œµ
   c. Si converge: TERMINAR con √©xito
   d. Si no: continuar iteraci√≥n
6. Si se alcanza N iteraciones: TERMINAR sin convergencia
7. FIN
```

## Criterios de Convergencia

**Teorema del Punto Fijo**: Si $g(x)$ es continua en $[a,b]$ y:
- $g([a,b]) \subseteq [a,b]$ (mapea el intervalo en s√≠ mismo)
- $|g'(x)| < 1$ para todo $x \in [a,b]$ (contracci√≥n)

Entonces existe un √∫nico punto fijo $x^*$ y la sucesi√≥n $x_{n+1} = g(x_n)$ converge a $x^*$.

# Implementaci√≥n Completa

```{python}
#!/usr/bin/env python3
"""
M√©todo de Punto Fijo - Implementaci√≥n con men√∫s interactivos
Iteraci√≥n x_{n+1} = g(x_n) para encontrar puntos fijos
"""

import numpy as np
import matplotlib.pyplot as plt
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import track
import sympy as sp
from typing import Callable, Tuple, List, Optional
import os

console = Console()

class MetodoPuntoFijo:
    """Implementaci√≥n del m√©todo de punto fijo con interfaz interactiva"""
    
    def __init__(self):
        self.funcion_str = ""
        self.funcion_sympy = None
        self.funcion_numpy = None
        self.x0 = 0.0
        self.tolerancia = 1e-6
        self.max_iteraciones = 100
        self.resultados = []
        
    def limpiar_pantalla(self):
        """Limpia la pantalla del terminal"""
        os.system('clear' if os.name == 'posix' else 'cls')
        
    def mostrar_banner(self):
        """Muestra el banner del m√©todo"""
        banner = Panel.fit(
            "[bold blue]üîÑ M√âTODO DE PUNTO FIJO[/bold blue]\n"
            "[italic]Iteraci√≥n x_{n+1} = g(x_n) para encontrar puntos fijos[/italic]",
            border_style="blue"
        )
        console.print(banner)
        console.print()
    
    def mostrar_menu_principal(self) -> str:
        """Muestra el men√∫ principal y retorna la opci√≥n seleccionada"""
        self.limpiar_pantalla()
        self.mostrar_banner()
        
        table = Table(show_header=False, box=None, padding=(0, 2))
        table.add_column("Opci√≥n", style="bold cyan", width=8)
        table.add_column("Descripci√≥n", style="white")
        
        opciones = [
            ("1", "üéØ Ingresar funci√≥n g(x)"),
            ("2", "üìç Configurar valor inicial x‚ÇÄ"),
            ("3", "‚öôÔ∏è  Configurar par√°metros"),
            ("4", "üöÄ Ejecutar m√©todo"),
            ("5", "üìä Ver resultados"),
            ("6", "üìà An√°lisis de convergencia"),
            ("7", "‚ùì Ayuda"),
            ("8", "üö™ Salir")
        ]
        
        for opcion, desc in opciones:
            table.add_row(opcion, desc)
        
        console.print(table)
        return input("\nüîπ Seleccione una opci√≥n: ").strip()
    
    def ingresar_funcion(self):
        """Permite al usuario ingresar la funci√≥n g(x)"""
        self.limpiar_pantalla()
        
        panel_ayuda = Panel(
            "[bold cyan]Ingrese la funci√≥n g(x) para x = g(x)[/bold cyan]\n\n"
            "Ejemplos de transformaciones:\n"
            "‚Ä¢ f(x) = x¬≤ - 3x + 2 = 0  ‚Üí  g(x) = (x¬≤ + 2)/3\n"
            "‚Ä¢ f(x) = cos(x) - x = 0   ‚Üí  g(x) = cos(x)\n"
            "‚Ä¢ f(x) = eÀ£ - 2x - 1 = 0  ‚Üí  g(x) = (eÀ£ - 1)/2\n\n"
            "[yellow]Funciones disponibles:[/yellow]\n"
            "sin, cos, tan, exp, log, ln, sqrt, abs\n\n"
            "[green]üí° La convergencia depende de |g'(x)| < 1[/green]",
            title="üí° Ayuda para Funciones",
            border_style="blue"
        )
        console.print(panel_ayuda)
        
        while True:
            try:
                funcion_input = input("\nIngrese g(x): ").strip()
                
                if not funcion_input:
                    console.print("[red]‚ùå La funci√≥n no puede estar vac√≠a[/red]")
                    continue
                
                # Procesar la funci√≥n con SymPy
                x = sp.Symbol('x')
                funcion_input = funcion_input.replace('^', '**')
                self.funcion_sympy = sp.sympify(funcion_input)
                self.funcion_numpy = sp.lambdify(x, self.funcion_sympy, 'numpy')
                self.funcion_str = funcion_input
                
                # Probar la funci√≥n en algunos puntos
                console.print(f"\n[green]‚úÖ Funci√≥n ingresada: g(x) = {funcion_input}[/green]")
                
                # Mostrar algunos valores de prueba
                test_table = Table(title="Valores de Prueba")
                test_table.add_column("x", justify="center", style="cyan")
                test_table.add_column("g(x)", justify="center", style="green")
                
                for val in [0, 1, -1, 0.5]:
                    try:
                        result = float(self.funcion_numpy(val))
                        test_table.add_row(str(val), f"{result:.6f}")
                    except:
                        test_table.add_row(str(val), "No definido")
                        
                console.print(test_table)
                
                # Calcular y mostrar la derivada
                try:
                    derivada = sp.diff(self.funcion_sympy, x)
                    console.print(f"\n[blue]Derivada: g'(x) = {derivada}[/blue]")
                    console.print("[yellow]üí° Para convergencia se requiere |g'(x)| < 1 cerca del punto fijo[/yellow]")
                except:
                    console.print("\n[yellow]‚ö†Ô∏è  No se pudo calcular la derivada autom√°ticamente[/yellow]")
                
                break
                
            except Exception as e:
                console.print(f"[red]‚ùå Error en la funci√≥n: {str(e)}[/red]")
                console.print("Revise la sintaxis. Use 'exp', 'sin', 'cos', 'log', etc.")
                
        input("\nPresione Enter para continuar...")
    
    def configurar_valor_inicial(self):
        """Configura el valor inicial x‚ÇÄ"""
        self.limpiar_pantalla()
        console.print("[bold blue]üìç CONFIGURACI√ìN DEL VALOR INICIAL[/bold blue]\n")
        
        console.print("El valor inicial x‚ÇÄ es crucial para la convergencia del m√©todo.")
        console.print("Elija un valor cercano a donde espera que est√© la soluci√≥n.\n")
        
        while True:
            try:
                x0_input = input(f"Ingrese x‚ÇÄ (actual: {self.x0}): ").strip()
                
                if x0_input:
                    self.x0 = float(x0_input)
                    
                    # Si hay funci√≥n, evaluar en x‚ÇÄ
                    if self.funcion_numpy:
                        try:
                            g_x0 = self.funcion_numpy(self.x0)
                            console.print(f"\n[green]‚úÖ x‚ÇÄ = {self.x0}[/green]")
                            console.print(f"[cyan]g(x‚ÇÄ) = {g_x0:.6f}[/cyan]")
                            
                            # Mostrar si est√° cerca de ser punto fijo
                            diferencia = abs(g_x0 - self.x0)
                            if diferencia < 1:
                                console.print(f"[green]|g(x‚ÇÄ) - x‚ÇÄ| = {diferencia:.6f} (promisorio)[/green]")
                            else:
                                console.print(f"[yellow]|g(x‚ÇÄ) - x‚ÇÄ| = {diferencia:.6f} (puede no converger)[/yellow]")
                        except:
                            console.print(f"\n[green]‚úÖ x‚ÇÄ = {self.x0}[/green]")
                            console.print("[red]‚ö†Ô∏è  No se pudo evaluar g(x‚ÇÄ)[/red]")
                    else:
                        console.print(f"\n[green]‚úÖ x‚ÇÄ = {self.x0}[/green]")
                else:
                    console.print(f"\n[green]‚úÖ Manteniendo x‚ÇÄ = {self.x0}[/green]")
                
                break
                
            except ValueError:
                console.print("[red]‚ùå Por favor ingrese un n√∫mero v√°lido[/red]")
        
        input("\nPresione Enter para continuar...")
    
    def configurar_parametros(self):
        """Configura tolerancia y n√∫mero m√°ximo de iteraciones"""
        self.limpiar_pantalla()
        console.print("[bold blue]‚öôÔ∏è CONFIGURACI√ìN DE PAR√ÅMETROS[/bold blue]\n")
        
        # Mostrar configuraci√≥n actual
        config_table = Table(title="Configuraci√≥n Actual")
        config_table.add_column("Par√°metro", style="cyan")
        config_table.add_column("Valor", style="green")
        
        config_table.add_row("Tolerancia", f"{self.tolerancia}")
        config_table.add_row("M√°x. iteraciones", f"{self.max_iteraciones}")
        
        console.print(config_table)
        
        # Configurar tolerancia
        while True:
            try:
                tol_input = input(f"\nNueva tolerancia (actual: {self.tolerancia}): ").strip()
                if tol_input:
                    nueva_tol = float(tol_input)
                    if nueva_tol <= 0:
                        console.print("[red]‚ùå La tolerancia debe ser positiva[/red]")
                        continue
                    self.tolerancia = nueva_tol
                    console.print(f"[green]‚úÖ Tolerancia actualizada: {nueva_tol}[/green]")
                break
            except ValueError:
                console.print("[red]‚ùå Ingrese un n√∫mero v√°lido[/red]")
        
        # Configurar m√°ximo de iteraciones
        while True:
            try:
                iter_input = input(f"Nuevo m√°ximo de iteraciones (actual: {self.max_iteraciones}): ").strip()
                if iter_input:
                    nuevo_max = int(iter_input)
                    if nuevo_max <= 0:
                        console.print("[red]‚ùå El n√∫mero de iteraciones debe ser positivo[/red]")
                        continue
                    self.max_iteraciones = nuevo_max
                    console.print(f"[green]‚úÖ M√°ximo de iteraciones actualizado: {nuevo_max}[/green]")
                break
            except ValueError:
                console.print("[red]‚ùå Ingrese un n√∫mero entero v√°lido[/red]")
        
        input("\nPresione Enter para continuar...")
    
    def ejecutar_metodo(self):
        """Ejecuta el m√©todo de punto fijo"""
        if not self.funcion_numpy:
            console.print("[red]‚ùå Debe ingresar una funci√≥n g(x) primero[/red]")
            input("Presione Enter para continuar...")
            return
        
        self.limpiar_pantalla()
        console.print("[bold blue]üöÄ EJECUTANDO M√âTODO DE PUNTO FIJO[/bold blue]\n")
        
        # Mostrar configuraci√≥n
        console.print(f"Funci√≥n: g(x) = {self.funcion_str}")
        console.print(f"Valor inicial: x‚ÇÄ = {self.x0}")
        console.print(f"Tolerancia: {self.tolerancia}")
        console.print(f"M√°x. iteraciones: {self.max_iteraciones}\n")
        
        # Inicializar
        self.resultados = []
        x_actual = self.x0
        
        console.print("Iniciando iteraciones...\n")
        
        # Crear tabla para mostrar iteraciones
        tabla_iter = Table(title="Iteraciones del M√©todo de Punto Fijo")
        tabla_iter.add_column("n", justify="center", style="cyan")
        tabla_iter.add_column("x‚Çô", justify="center", style="green")
        tabla_iter.add_column("g(x‚Çô)", justify="center", style="yellow")
        tabla_iter.add_column("Error", justify="center", style="red")
        
        # Barra de progreso
        for i in track(range(self.max_iteraciones), description="Iterando..."):
            try:
                # Calcular siguiente valor
                x_siguiente = self.funcion_numpy(x_actual)
                
                # Calcular error
                error = abs(x_siguiente - x_actual)
                
                # Guardar resultado
                self.resultados.append({
                    'iteracion': i,
                    'x': x_actual,
                    'g_x': x_siguiente,
                    'error': error
                })
                
                # Mostrar en tabla (primeras 10 iteraciones)
                if i < 10:
                    tabla_iter.add_row(
                        str(i),
                        f"{x_actual:.6f}",
                        f"{x_siguiente:.6f}",
                        f"{error:.2e}"
                    )
                
                # Verificar convergencia
                if error < self.tolerancia:
                    console.print(f"\n[green]üéâ ¬°Convergencia alcanzada en {i+1} iteraciones![/green]")
                    console.print(f"[green]Punto fijo encontrado: x* ‚âà {x_siguiente:.8f}[/green]")
                    console.print(f"[green]Error final: {error:.2e}[/green]")
                    break
                
                # Verificar divergencia
                if abs(x_siguiente) > 1e10:
                    console.print(f"\n[red]üí• El m√©todo est√° divergiendo (|x| > 10¬π‚Å∞)[/red]")
                    break
                
                x_actual = x_siguiente
                
            except Exception as e:
                console.print(f"\n[red]‚ùå Error durante la iteraci√≥n {i}: {str(e)}[/red]")
                break
        else:
            console.print(f"\n[yellow]‚ö†Ô∏è  Se alcanz√≥ el m√°ximo de iteraciones ({self.max_iteraciones})[/yellow]")
            console.print(f"[yellow]√öltima aproximaci√≥n: x ‚âà {x_actual:.8f}[/yellow]")
            console.print(f"[yellow]Error estimado: {error:.2e}[/yellow]")
        
        # Mostrar tabla de iteraciones
        console.print(tabla_iter)
        
        if len(self.resultados) > 10:
            console.print(f"\n[blue]... y {len(self.resultados) - 10} iteraciones m√°s[/blue]")
        
        input("\nPresione Enter para continuar...")
    
    def ver_resultados(self):
        """Muestra los resultados detallados"""
        if not self.resultados:
            console.print("[red]‚ùå No hay resultados disponibles. Execute el m√©todo primero.[/red]")
            input("Presione Enter para continuar...")
            return
        
        self.limpiar_pantalla()
        console.print("[bold blue]üìä RESULTADOS DETALLADOS[/bold blue]\n")
        
        ultimo = self.resultados[-1]
        
        # Panel de resumen
        resumen = Panel(
            f"[bold green]Soluci√≥n encontrada:[/bold green] x* ‚âà {ultimo['g_x']:.8f}\n"
            f"[bold blue]Iteraciones realizadas:[/bold blue] {len(self.resultados)}\n"
            f"[bold yellow]Error final:[/bold yellow] {ultimo['error']:.2e}\n"
            f"[bold cyan]Funci√≥n evaluada:[/bold cyan] g(x) = {self.funcion_str}",
            title="üìã Resumen de Resultados",
            border_style="green"
        )
        console.print(resumen)
        
        # An√°lisis de convergencia
        if len(self.resultados) > 1:
            errores = [r['error'] for r in self.resultados[1:]]
            
            console.print("\n[bold blue]üìà An√°lisis de Convergencia:[/bold blue]")
            
            # Verificar tipo de convergencia
            if len(errores) > 3:
                razones = [errores[i]/errores[i-1] for i in range(2, min(len(errores), 10)) if errores[i-1] != 0]
                if razones:
                    razon_promedio = sum(razones) / len(razones)
                    console.print(f"Raz√≥n de convergencia promedio: {razon_promedio:.4f}")
                    
                    if razon_promedio < 1:
                        console.print("[green]‚úÖ Convergencia lineal confirmada[/green]")
                    else:
                        console.print("[yellow]‚ö†Ô∏è  Convergencia lenta o divergencia[/yellow]")
        
        # Mostrar tabla completa de resultados
        console.print("\n[bold blue]üìã Tabla Completa de Iteraciones:[/bold blue]")
        
        tabla_completa = Table(title="Resultados Completos")
        tabla_completa.add_column("Iteraci√≥n", justify="center", style="cyan")
        tabla_completa.add_column("x‚Çô", justify="center", style="green")
        tabla_completa.add_column("g(x‚Çô) = x‚Çô‚Çä‚ÇÅ", justify="center", style="yellow")
        tabla_completa.add_column("Error |x‚Çô‚Çä‚ÇÅ - x‚Çô|", justify="center", style="red")
        
        # Mostrar todas las iteraciones (limitado a 20 para legibilidad)
        max_mostrar = min(len(self.resultados), 20)
        for i in range(max_mostrar):
            r = self.resultados[i]
            tabla_completa.add_row(
                str(r['iteracion']),
                f"{r['x']:.8f}",
                f"{r['g_x']:.8f}",
                f"{r['error']:.2e}"
            )
        
        if len(self.resultados) > 20:
            tabla_completa.add_row("...", "...", "...", "...")
            ultimo = self.resultados[-1]
            tabla_completa.add_row(
                str(ultimo['iteracion']),
                f"{ultimo['x']:.8f}",
                f"{ultimo['g_x']:.8f}",
                f"{ultimo['error']:.2e}"
            )
        
        console.print(tabla_completa)
        input("\nPresione Enter para continuar...")
    
    def analisis_convergencia(self):
        """Muestra an√°lisis gr√°fico de convergencia"""
        if not self.resultados:
            console.print("[red]‚ùå No hay resultados disponibles.[/red]")
            input("Presione Enter para continuar...")
            return
        
        # Extraer datos para gr√°ficos
        iteraciones = [r['iteracion'] for r in self.resultados]
        valores_x = [r['x'] for r in self.resultados]
        errores = [r['error'] for r in self.resultados[1:]]  # Sin el error inicial
        
        # Crear figura con subplots
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 10))
        fig.suptitle(f'An√°lisis de Convergencia - M√©todo de Punto Fijo\ng(x) = {self.funcion_str}', fontsize=14)
        
        # 1. Convergencia de x
        ax1.plot(iteraciones, valores_x, 'b-o', markersize=4, linewidth=2)
        ax1.set_xlabel('Iteraci√≥n')
        ax1.set_ylabel('Valor de x')
        ax1.set_title('Convergencia de la Soluci√≥n')
        ax1.grid(True, alpha=0.3)
        
        # L√≠nea horizontal en la soluci√≥n final
        if self.resultados:
            ax1.axhline(y=self.resultados[-1]['g_x'], color='red', linestyle='--', alpha=0.7, label='Soluci√≥n final')
            ax1.legend()
        
        # 2. Error absoluto (escala logar√≠tmica)
        if errores:
            ax2.semilogy(range(1, len(errores)+1), errores, 'r-o', markersize=4, linewidth=2)
            ax2.set_xlabel('Iteraci√≥n')
            ax2.set_ylabel('Error |x‚Çô‚Çä‚ÇÅ - x‚Çô|')
            ax2.set_title('Evoluci√≥n del Error (Escala Log)')
            ax2.grid(True, alpha=0.3)
        
        # 3. Diagrama de telara√±a (cobweb plot)
        if len(valores_x) > 1:
            x_min = min(valores_x) - 0.5
            x_max = max(valores_x) + 0.5
            x_plot = np.linspace(x_min, x_max, 1000)
            
            try:
                y_plot = [self.funcion_numpy(x) for x in x_plot]
                
                ax3.plot(x_plot, y_plot, 'b-', linewidth=2, label='g(x)')
                ax3.plot(x_plot, x_plot, 'k--', alpha=0.5, label='y = x')
                
                # Dibujar telara√±a
                for i in range(min(len(valores_x)-1, 20)):  # Limitar para claridad
                    x_curr = valores_x[i]
                    x_next = self.resultados[i]['g_x']
                    
                    # L√≠nea vertical
                    ax3.plot([x_curr, x_curr], [x_curr, x_next], 'r-', alpha=0.7, linewidth=1)
                    # L√≠nea horizontal
                    ax3.plot([x_curr, x_next], [x_next, x_next], 'r-', alpha=0.7, linewidth=1)
                
                ax3.set_xlabel('x')
                ax3.set_ylabel('g(x)')
                ax3.set_title('Diagrama de Telara√±a')
                ax3.legend()
                ax3.grid(True, alpha=0.3)
                
            except Exception as e:
                ax3.text(0.5, 0.5, f'Error al generar gr√°fico:\n{str(e)}', 
                        ha='center', va='center', transform=ax3.transAxes)
        
        # 4. Raz√≥n de convergencia
        if len(errores) > 2:
            razones = [errores[i]/errores[i-1] for i in range(1, len(errores)) if errores[i-1] != 0]
            
            if razones:
                ax4.plot(range(2, len(razones)+2), razones, 'g-o', markersize=4, linewidth=2)
                ax4.axhline(y=1, color='red', linestyle='--', alpha=0.7, label='L√≠mite de convergencia')
                ax4.set_xlabel('Iteraci√≥n')
                ax4.set_ylabel('Error(n) / Error(n-1)')
                ax4.set_title('Raz√≥n de Convergencia')
                ax4.legend()
                ax4.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.show()
        
        input("\nPresione Enter para continuar...")
    
    def mostrar_ayuda(self):
        """Muestra informaci√≥n de ayuda del m√©todo"""
        self.limpiar_pantalla()
        
        ayuda_texto = Panel(
            """
[bold blue]üîÑ M√âTODO DE PUNTO FIJO[/bold blue]

[bold green]¬øQu√© hace?[/bold green]
Encuentra soluciones de ecuaciones de la forma x = g(x) mediante iteraci√≥n sucesiva.

[bold yellow]Algoritmo:[/bold yellow]
1. Transformar f(x) = 0 en x = g(x)
2. Elegir valor inicial x‚ÇÄ
3. Iterar: x‚Çô‚Çä‚ÇÅ = g(x‚Çô)
4. Parar cuando |x‚Çô‚Çä‚ÇÅ - x‚Çô| < tolerancia

[bold cyan]Convergencia:[/bold cyan]
‚Ä¢ Requiere |g'(x)| < 1 cerca del punto fijo
‚Ä¢ Convergencia lineal t√≠picamente
‚Ä¢ Sensible al valor inicial x‚ÇÄ

[bold red]Transformaciones comunes:[/bold red]
‚Ä¢ x¬≤ - 3x + 2 = 0  ‚Üí  x = (x¬≤ + 2)/3
‚Ä¢ cos(x) - x = 0   ‚Üí  x = cos(x)
‚Ä¢ eÀ£ - 2x - 1 = 0  ‚Üí  x = (eÀ£ - 1)/2

[bold magenta]Consejos pr√°cticos:[/bold magenta]
‚Ä¢ Pruebe diferentes transformaciones si no converge
‚Ä¢ Use gr√°ficos para estimar x‚ÇÄ
‚Ä¢ Verifique |g'(x)| < 1 en la regi√≥n de inter√©s
‚Ä¢ El diagrama de telara√±a ayuda a visualizar convergencia
            """,
            title="üìö Ayuda - M√©todo de Punto Fijo",
            border_style="blue"
        )
        
        console.print(ayuda_texto)
        input("\nPresione Enter para continuar...")

def main():
    """Funci√≥n principal"""
    metodo = MetodoPuntoFijo()
    
    while True:
        opcion = metodo.mostrar_menu_principal()
        
        if opcion == "1":
            metodo.ingresar_funcion()
        elif opcion == "2":
            metodo.configurar_valor_inicial()
        elif opcion == "3":
            metodo.configurar_parametros()
        elif opcion == "4":
            metodo.ejecutar_metodo()
        elif opcion == "5":
            metodo.ver_resultados()
        elif opcion == "6":
            metodo.analisis_convergencia()
        elif opcion == "7":
            metodo.mostrar_ayuda()
        elif opcion == "8":
            console.print("\n[bold green]¬°Gracias por usar el m√©todo de punto fijo![/bold green]")
            break
        else:
            console.print("[red]Opci√≥n inv√°lida. Seleccione un n√∫mero del 1 al 8.[/red]")
            input("Presione Enter para continuar...")

if __name__ == "__main__":
    main()
```

# Interfaz de Usuario

## Flujo de Men√∫s

El programa presenta un men√∫ principal numerado con las siguientes opciones:

1. **üéØ Ingresar funci√≥n g(x)**: Permite ingresar la funci√≥n de iteraci√≥n
2. **üìç Configurar valor inicial x‚ÇÄ**: Define el punto de partida
3. **‚öôÔ∏è Configurar par√°metros**: Ajusta tolerancia e iteraciones m√°ximas  
4. **üöÄ Ejecutar m√©todo**: Ejecuta el algoritmo de punto fijo
5. **üìä Ver resultados**: Muestra resultados detallados
6. **üìà An√°lisis de convergencia**: Gr√°ficos de convergencia y diagn√≥stico
7. **‚ùì Ayuda**: Informaci√≥n sobre el m√©todo
8. **üö™ Salir**: Termina el programa

## Caracter√≠sticas de la Interfaz

- **Men√∫s coloridos**: Uso de Rich para presentaci√≥n atractiva
- **Validaci√≥n de entrada**: Verificaci√≥n robusta de datos del usuario
- **Feedback inmediato**: Mensajes de estado y progreso
- **Tablas formateadas**: Presentaci√≥n clara de iteraciones y resultados
- **Gr√°ficos interactivos**: Visualizaci√≥n en tiempo real con Matplotlib

# Ejemplos de Ejecuci√≥n

## Ejemplo 1: Ecuaci√≥n Simple

**Problema**: Resolver $x^2 - 3x + 2 = 0$

**Transformaci√≥n**: $x = \frac{x^2 + 2}{3}$

```
Funci√≥n: g(x) = (x**2 + 2)/3
Valor inicial: x‚ÇÄ = 1.5
Tolerancia: 1e-6

Resultados:
Iteraci√≥n | x‚Çô        | g(x‚Çô)     | Error
0         | 1.500000  | 1.416667  | 8.33e-02
1         | 1.416667  | 1.334028  | 8.26e-02
2         | 1.334028  | 1.259368  | 7.47e-02
...
15        | 1.000000  | 1.000000  | 1.85e-07

¬°Convergencia alcanzada en 16 iteraciones!
Punto fijo: x* ‚âà 1.00000000
```

## Ejemplo 2: Ecuaci√≥n Transcendental

**Problema**: Resolver $\cos(x) - x = 0$

**Transformaci√≥n**: $x = \cos(x)$

```
Funci√≥n: g(x) = cos(x)
Valor inicial: x‚ÇÄ = 0.5
Tolerancia: 1e-8

Resultados:
Iteraci√≥n | x‚Çô        | g(x‚Çô)     | Error
0         | 0.500000  | 0.877583  | 3.78e-01
1         | 0.877583  | 0.639012  | 2.39e-01
2         | 0.639012  | 0.802685  | 1.64e-01
...
23        | 0.739085  | 0.739085  | 8.45e-09

¬°Convergencia alcanzada en 24 iteraciones!
Punto fijo: x* ‚âà 0.73908513
```

# Visualizaciones

## Gr√°ficos Generados

1. **Convergencia de la soluci√≥n**: Evoluci√≥n de $x_n$ vs iteraci√≥n
2. **Error absoluto**: $|x_{n+1} - x_n|$ en escala logar√≠tmica
3. **Diagrama de telara√±a**: Visualizaci√≥n geom√©trica de la convergencia
4. **Raz√≥n de convergencia**: An√°lisis del factor de convergencia

## Interpretaci√≥n Visual

- **Diagrama de telara√±a**: Muestra c√≥mo las iteraciones "se acercan" al punto fijo
- **Convergencia exponencial**: Error decrece exponencialmente si $|g'(x)| < 1$
- **Oscilaciones**: Indican que $g'(x)$ es negativo en el punto fijo

# Ideas de Mejora

## Optimizaciones T√©cnicas

1. **Aceleraci√≥n de Aitken**: Para mejorar velocidad de convergencia
2. **M√©todos de Newton modificados**: Combinaci√≥n con Newton-Raphson
3. **Detecci√≥n autom√°tica de divergencia**: Par√°metros adaptativos
4. **Transformaciones m√∫ltiples**: Probar varias formas de $g(x)$ autom√°ticamente

## Funcionalidades Adicionales

1. **An√°lisis gr√°fico interactivo**: Zoom y an√°lisis detallado
2. **Comparaci√≥n de transformaciones**: Evaluar diferentes $g(x)$
3. **Estimaci√≥n de regi√≥n de convergencia**: An√°lisis de estabilidad
4. **Exportaci√≥n de resultados**: Guardar datos y gr√°ficos
5. **Modo batch**: Procesar m√∫ltiples problemas autom√°ticamente

## Mejoras en la Interfaz

1. **Asistente de transformaci√≥n**: Ayuda para convertir $f(x) = 0$ a $x = g(x)$
2. **Predictor de convergencia**: Estimaci√≥n basada en $g'(x)$
3. **Modo tutorial**: Ejemplos guiados paso a paso
4. **Configuraci√≥n avanzada**: M√°s par√°metros de control

# Complicaciones Encontradas

## Desaf√≠os de Implementaci√≥n

### 1. Validaci√≥n de Funciones
**Problema**: Verificar que $g(x)$ est√© bien definida y sea evaluable

**Soluci√≥n**: 
- Evaluaci√≥n en puntos de prueba antes de comenzar iteraciones
- Manejo de excepciones durante evaluaci√≥n
- Verificaci√≥n de dominio y rango

### 2. Detecci√≥n de Divergencia
**Problema**: El m√©todo puede divergir o converger muy lentamente

**Soluci√≥n**:
- L√≠mites en el valor absoluto de $x$ (|x| > 10¬π‚Å∞)
- An√°lisis de la raz√≥n de convergencia
- Advertencias cuando $|g'(x)| \geq 1$

### 3. Casos Edge
**Problema**: Situaciones especiales que requieren manejo espec√≠fico

**Casos identificados**:
- $g(x)$ no definida en algunos puntos
- Convergencia a ciclos en lugar de puntos fijos
- Convergencia extremadamente lenta
- Puntos fijos m√∫ltiples

**Soluciones**:
- Manejo robusto de excepciones
- Detecci√≥n de ciclos (comparar con valores anteriores)
- L√≠mites adaptativos en iteraciones
- Informaci√≥n sobre multiplicidad de soluciones

### 4. Visualizaci√≥n de Convergencia
**Problema**: Crear gr√°ficos informativos para diferentes tipos de comportamiento

**Soluci√≥n**:
- Diagrama de telara√±a adaptativo
- Escalas autom√°ticas para diferentes rangos
- Colores y estilos que faciliten interpretaci√≥n
- L√≠mites inteligentes en ejes

## Casos Problem√°ticos Comunes

1. **$g(x) = x^2$**: Diverge para $|x_0| > 1$
2. **$g(x) = -x + 2$**: Oscila entre dos valores
3. **$g(x) = x + 0.1\sin(x)$**: Convergencia muy lenta
4. **$g(x) = 1/x$**: Problemas en $x = 0$

# Manual de Uso

## Instalaci√≥n y Requisitos

```bash
# Instalar dependencias
pip install numpy matplotlib rich sympy

# Ejecutar el programa
python punto_fijo.py
```

## Gu√≠a Paso a Paso

### Paso 1: Preparaci√≥n
1. Tener la ecuaci√≥n $f(x) = 0$ que desea resolver
2. Transformarla a la forma $x = g(x)$
3. Estimar d√≥nde puede estar la soluci√≥n

### Paso 2: Configuraci√≥n
1. **Ejecutar el programa** y seleccionar opci√≥n 1
2. **Ingresar $g(x)$** usando sintaxis Python (ej: `cos(x)`, `x**2/3 + 1`)
3. **Configurar $x_0$** (opci√≥n 2) cerca de la soluci√≥n esperada
4. **Ajustar par√°metros** (opci√≥n 3) si es necesario

### Paso 3: Ejecuci√≥n
1. **Ejecutar m√©todo** (opci√≥n 4)
2. **Observar convergencia** en tiempo real
3. **Analizar resultados** (opci√≥n 5)
4. **Ver gr√°ficos** (opci√≥n 6) para comprensi√≥n visual

### Paso 4: Interpretaci√≥n
- **Convergi√≥**: Soluci√≥n encontrada exitosamente
- **No convergi√≥**: Probar diferente $x_0$ o transformaci√≥n
- **Divergi√≥**: La funci√≥n $g(x)$ no es contractiva

## Consejos de Uso

1. **Elecci√≥n de $g(x)$**: La forma de transformar $f(x) = 0$ es crucial
2. **Valor inicial**: Use gr√°ficos o conocimiento del problema para estimarlo
3. **Tolerancia**: $10^{-6}$ es t√≠picamente suficiente para la mayor√≠a de aplicaciones
4. **Convergencia lenta**: Considere usar aceleraci√≥n o m√©todos alternativos

## Resoluci√≥n de Problemas

| Problema | Causa Probable | Soluci√≥n |
|----------|----------------|----------|
| No converge | $\|g'(x)\| \geq 1$ | Cambiar transformaci√≥n o $x_0$ |
| Converge lento | $g'(x)$ cerca de 1 | Usar aceleraci√≥n o Newton-Raphson |
| Error de funci√≥n | Sintaxis incorrecta | Verificar funciones disponibles |
| Diverge r√°pidamente | $x_0$ fuera de regi√≥n de convergencia | Probar $x_0$ diferente |

---

*Este documento forma parte del proyecto personal de m√©todos num√©ricos desarrollado como material educativo para Ingenier√≠a en Computaci√≥n.*
