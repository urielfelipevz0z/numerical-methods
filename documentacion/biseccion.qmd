---
title: "M√©todo de Bisecci√≥n"
author: "Proyecto Personal - Ingenier√≠a en Computaci√≥n"  
date: today
format: 
  html:
    theme: cosmo
    code-fold: true
    toc: true
    number-sections: true
    highlight-style: github
    fig-width: 10
    fig-height: 6
    embed-resources: true
execute:
  warning: false
  echo: true
---

# ¬øPara qu√© sirve?

El m√©todo de bisecci√≥n es uno de los m√©todos m√°s fundamentales y confiables para encontrar ra√≠ces de ecuaciones no lineales. Sus principales aplicaciones incluyen:

## Aplicaciones Pr√°cticas

- **Ingenier√≠a Civil**: C√°lculo de cargas cr√≠ticas en estructuras
- **F√≠sica**: Determinaci√≥n de puntos de equilibrio en sistemas din√°micos
- **Econom√≠a**: Encontrar puntos de equilibrio en modelos econ√≥micos
- **Ciencias de la Computaci√≥n**: B√∫squeda en algoritmos de optimizaci√≥n
- **Matem√°ticas Aplicadas**: Soluci√≥n de ecuaciones trascendentales

## Ventajas del M√©todo

1. **Convergencia garantizada**: Siempre converge si la funci√≥n es continua y cambia de signo
2. **Simplicidad**: F√°cil de implementar y entender
3. **Robustez**: No requiere derivadas ni aproximaciones iniciales complejas
4. **Estabilidad num√©rica**: Menos susceptible a errores de redondeo

## Limitaciones

- Convergencia lineal (relativamente lenta)
- Requiere que la funci√≥n cambie de signo en el intervalo
- Solo encuentra una ra√≠z a la vez

# ¬øC√≥mo funciona?

El m√©todo de bisecci√≥n se basa en el **Teorema del Valor Intermedio**: si una funci√≥n continua $f(x)$ tiene signos opuestos en los extremos de un intervalo $[a,b]$, entonces existe al menos una ra√≠z en ese intervalo.

## Algoritmo Paso a Paso

1. **Verificar condiciones iniciales**: 
   - $f(a) \cdot f(b) < 0$ (signos opuestos)
   - La funci√≥n debe ser continua en $[a,b]$

2. **Calcular punto medio**:
   $$c = \frac{a + b}{2}$$

3. **Evaluar la funci√≥n en el punto medio**: $f(c)$

4. **Determinar nuevo intervalo**:
   - Si $f(a) \cdot f(c) < 0$: la ra√≠z est√° en $[a,c]$, entonces $b = c$
   - Si $f(c) \cdot f(b) < 0$: la ra√≠z est√° en $[c,b]$, entonces $a = c$
   - Si $f(c) = 0$: encontramos la ra√≠z exacta

5. **Verificar criterios de parada**:
   - Error absoluto: $|b - a| < \text{tolerancia}$
   - Error relativo: $\frac{|b - a|}{|c|} < \text{tolerancia}$
   - N√∫mero m√°ximo de iteraciones alcanzado

6. **Repetir desde el paso 2** hasta cumplir criterios de parada

## An√°lisis de Convergencia

La convergencia del m√©todo de bisecci√≥n es **lineal** con factor de convergencia $1/2$:

$$e_{n+1} \leq \frac{1}{2}e_n$$

Donde $e_n$ es el error en la iteraci√≥n $n$.

**N√∫mero de iteraciones necesarias**:
$$n \geq \frac{\log(b_0 - a_0) - \log(\varepsilon)}{\log(2)}$$

Donde $\varepsilon$ es la tolerancia deseada y $[a_0, b_0]$ es el intervalo inicial.

# Implementaci√≥n Completa

```{python}
#!/usr/bin/env python3
"""
M√©todo de Bisecci√≥n - Implementaci√≥n con men√∫s interactivos
Encuentra ra√≠ces de ecuaciones no lineales mediante bisecci√≥n de intervalos
"""

import numpy as np
import matplotlib.pyplot as plt
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.prompt import Prompt, FloatPrompt
from rich import print as rprint
import sympy as sp
from tqdm import tqdm
import os
from typing import Callable, Tuple, List, Optional

console = Console()

class MetodoBiseccion:
    """Implementaci√≥n del m√©todo de bisecci√≥n con interfaz interactiva"""
    
    def __init__(self):
        self.funcion_str = ""
        self.funcion_sympy = None
        self.funcion_numpy = None
        self.a = 0.0
        self.b = 0.0
        self.tolerancia = 1e-6
        self.max_iteraciones = 100
        self.resultados = []
        self.x_vals = []
        self.y_vals = []
        
    def limpiar_pantalla(self):
        """Limpia la pantalla del terminal"""
        os.system('clear' if os.name == 'posix' else 'cls')
        
    def mostrar_banner(self):
        """Muestra el banner del m√©todo"""
        banner = Panel.fit(
            "[bold blue]üî¢ M√âTODO DE BISECCI√ìN[/bold blue]\n"
            "[italic]B√∫squeda de ra√≠ces por bisecci√≥n de intervalos[/italic]",
            border_style="blue"
        )
        console.print(banner)
        console.print()
    
    def mostrar_menu_principal(self) -> str:
        """Muestra el men√∫ principal y retorna la opci√≥n seleccionada"""
        self.limpiar_pantalla()
        self.mostrar_banner()
        
        table = Table(show_header=False, box=None, padding=(0, 2))
        table.add_column("Opci√≥n", style="bold cyan", width=8)
        table.add_column("Descripci√≥n", style="white")
        
        opciones = [
            ("1", "üìù Ingresar funci√≥n"),
            ("2", "üìä Configurar intervalo [a,b]"),
            ("3", "‚öôÔ∏è  Configurar par√°metros"),
            ("4", "üöÄ Ejecutar m√©todo"),
            ("5", "üìà Ver resultados anteriores"),
            ("6", "‚ùì Ayuda"),
            ("7", "üö™ Salir")
        ]
        
        for num, desc in opciones:
            table.add_row(num, desc)
            
        console.print(table)
        console.print()
        
        return Prompt.ask(
            "[bold yellow]Seleccione una opci√≥n[/bold yellow]",
            choices=[str(i) for i in range(1, 8)],
            default="1"
        )
    
    def ingresar_funcion(self):
        """Men√∫ para ingreso de funci√≥n"""
        self.limpiar_pantalla()
        console.print("[bold blue]üìù INGRESO DE FUNCI√ìN[/bold blue]\n")
        
        console.print("Ingrese la funci√≥n f(x) = 0 que desea resolver.")
        console.print("Ejemplos v√°lidos:")
        console.print("  ‚Ä¢ x**2 - 4")
        console.print("  ‚Ä¢ exp(x) - 2")
        console.print("  ‚Ä¢ sin(x) - 0.5")
        console.print("  ‚Ä¢ log(x) + x")
        console.print()
        
        while True:
            try:
                self.funcion_str = Prompt.ask("[yellow]f(x) =[/yellow]").strip()
                
                if not self.funcion_str:
                    console.print("[red]‚ùå Debe ingresar una funci√≥n[/red]")
                    continue
                
                # Crear funci√≥n simb√≥lica
                x = sp.Symbol('x')
                self.funcion_sympy = sp.sympify(self.funcion_str)
                
                # Convertir a funci√≥n numpy
                self.funcion_numpy = sp.lambdify(x, self.funcion_sympy, 'numpy')
                
                # Probar la funci√≥n
                test_vals = [0, 1, -1, 0.5, -0.5]
                for val in test_vals:
                    try:
                        resultado = float(self.funcion_numpy(val))
                        if not np.isfinite(resultado):
                            continue
                    except:
                        continue
                        
                console.print(f"[green]‚úÖ Funci√≥n ingresada exitosamente: f(x) = {self.funcion_str}[/green]")
                
                # Mostrar algunos valores de prueba
                console.print("\n[blue]Valores de prueba:[/blue]")
                test_table = Table()
                test_table.add_column("x", style="cyan")
                test_table.add_column("f(x)", style="yellow")
                
                for val in [-2, -1, 0, 1, 2]:
                    try:
                        fx = self.funcion_numpy(val)
                        test_table.add_row(str(val), f"{fx:.6f}")
                    except:
                        test_table.add_row(str(val), "No definido")
                        
                console.print(test_table)
                break
                
            except Exception as e:
                console.print(f"[red]‚ùå Error en la funci√≥n: {str(e)}[/red]")
                console.print("Revise la sintaxis. Use 'exp', 'sin', 'cos', 'log', etc.")
                
        input("\nPresione Enter para continuar...")
    
    def configurar_intervalo(self):
        """Men√∫ para configurar el intervalo [a,b]"""
        self.limpiar_pantalla()
        console.print("[bold blue]üìä CONFIGURACI√ìN DEL INTERVALO[/bold blue]\n")
        
        if not self.funcion_numpy:
            console.print("[red]‚ùå Debe ingresar una funci√≥n primero[/red]")
            input("Presione Enter para continuar...")
            return
            
        console.print("El m√©todo de bisecci√≥n requiere un intervalo [a,b] donde:")
        console.print("  ‚Ä¢ f(a) y f(b) tengan signos opuestos")
        console.print("  ‚Ä¢ La funci√≥n sea continua en [a,b]")
        console.print()
        
        while True:
            try:
                self.a = FloatPrompt.ask("[yellow]Extremo izquierdo a[/yellow]")
                fa = float(self.funcion_numpy(self.a))
                
                self.b = FloatPrompt.ask("[yellow]Extremo derecho b[/yellow]")
                fb = float(self.funcion_numpy(self.b))
                
                if self.a >= self.b:
                    console.print("[red]‚ùå Debe cumplirse a < b[/red]")
                    continue
                    
                console.print(f"\n[blue]Verificaci√≥n del intervalo:[/blue]")
                console.print(f"f({self.a}) = {fa:.6f}")
                console.print(f"f({self.b}) = {fb:.6f}")
                console.print(f"f(a) √ó f(b) = {fa * fb:.6f}")
                
                if fa * fb > 0:
                    console.print("[red]‚ùå f(a) y f(b) deben tener signos opuestos[/red]")
                    console.print("No se garantiza la existencia de ra√≠z en este intervalo.")
                    
                    if not Prompt.ask(
                        "¬øDesea continuar de todas formas?", 
                        choices=["s", "n"], 
                        default="n"
                    ) == "s":
                        continue
                else:
                    console.print("[green]‚úÖ Intervalo v√°lido: existe al menos una ra√≠z[/green]")
                
                # Mostrar gr√°fico del intervalo
                self._mostrar_grafico_intervalo()
                break
                
            except Exception as e:
                console.print(f"[red]‚ùå Error: {str(e)}[/red]")
                
        input("\nPresione Enter para continuar...")
    
    def configurar_parametros(self):
        """Men√∫ para configurar par√°metros del m√©todo"""
        self.limpiar_pantalla()
        console.print("[bold blue]‚öôÔ∏è  CONFIGURACI√ìN DE PAR√ÅMETROS[/bold blue]\n")
        
        # Mostrar valores actuales
        table = Table()
        table.add_column("Par√°metro", style="cyan")
        table.add_column("Valor Actual", style="yellow")
        table.add_column("Descripci√≥n", style="white")
        
        table.add_row(
            "Tolerancia", 
            f"{self.tolerancia:.2e}", 
            "Error m√°ximo aceptable"
        )
        table.add_row(
            "Max. Iteraciones", 
            str(self.max_iteraciones), 
            "L√≠mite de iteraciones"
        )
        
        console.print(table)
        console.print()
        
        # Configurar tolerancia
        nueva_tol = FloatPrompt.ask(
            f"[yellow]Nueva tolerancia[/yellow] (actual: {self.tolerancia:.2e})",
            default=self.tolerancia
        )
        if nueva_tol > 0:
            self.tolerancia = nueva_tol
        
        # Configurar iteraciones
        nuevas_iter = int(Prompt.ask(
            f"[yellow]M√°ximo de iteraciones[/yellow] (actual: {self.max_iteraciones})",
            default=str(self.max_iteraciones)
        ))
        if nuevas_iter > 0:
            self.max_iteraciones = nuevas_iter
            
        console.print("[green]‚úÖ Par√°metros actualizados[/green]")
        input("Presione Enter para continuar...")
    
    def ejecutar_metodo(self):
        """Ejecuta el m√©todo de bisecci√≥n"""
        self.limpiar_pantalla()
        console.print("[bold blue]üöÄ EJECUCI√ìN DEL M√âTODO[/bold blue]\n")
        
        # Verificar que todo est√© configurado
        if not self.funcion_numpy:
            console.print("[red]‚ùå Debe ingresar una funci√≥n[/red]")
            input("Presione Enter para continuar...")
            return
            
        if self.a >= self.b:
            console.print("[red]‚ùå Debe configurar un intervalo v√°lido[/red]")
            input("Presione Enter para continuar...")
            return
        
        console.print(f"[blue]Funci√≥n:[/blue] f(x) = {self.funcion_str}")
        console.print(f"[blue]Intervalo:[/blue] [{self.a}, {self.b}]")
        console.print(f"[blue]Tolerancia:[/blue] {self.tolerancia:.2e}")
        console.print(f"[blue]Max. iteraciones:[/blue] {self.max_iteraciones}")
        console.print()
        
        if not Prompt.ask("¬øProceder con la ejecuci√≥n?", choices=["s", "n"], default="s") == "s":
            return
            
        # Ejecutar algoritmo
        self._ejecutar_algoritmo()
        
        # Mostrar resultados
        self._mostrar_resultados()
        
        input("\nPresione Enter para continuar...")
    
    def _ejecutar_algoritmo(self):
        """Ejecuta el algoritmo de bisecci√≥n"""
        a, b = self.a, self.b
        self.resultados = []
        
        fa = float(self.funcion_numpy(a))
        fb = float(self.funcion_numpy(b))
        
        console.print("[yellow]Ejecutando m√©todo de bisecci√≥n...[/yellow]\n")
        
        with tqdm(total=self.max_iteraciones, desc="Iteraciones") as pbar:
            for i in range(self.max_iteraciones):
                # Calcular punto medio
                c = (a + b) / 2
                fc = float(self.funcion_numpy(c))
                
                # Calcular errores
                error_abs = abs(b - a)
                error_rel = error_abs / abs(c) if c != 0 else float('inf')
                
                # Guardar resultado de la iteraci√≥n
                self.resultados.append({
                    'iteracion': i + 1,
                    'a': a,
                    'b': b,
                    'c': c,
                    'fa': fa,
                    'fb': fb,
                    'fc': fc,
                    'error_abs': error_abs,
                    'error_rel': error_rel,
                    'longitud_intervalo': b - a
                })
                
                # Verificar convergencia
                if error_abs < self.tolerancia or abs(fc) < self.tolerancia:
                    console.print(f"\n[green]‚úÖ Convergencia alcanzada en {i+1} iteraciones[/green]")
                    break
                
                # Determinar nuevo intervalo
                if fa * fc < 0:
                    b = c
                    fb = fc
                else:
                    a = c
                    fa = fc
                    
                pbar.update(1)
                pbar.set_postfix({
                    'Ra√≠z aprox.': f'{c:.6f}',
                    'Error': f'{error_abs:.2e}'
                })
        else:
            console.print(f"\n[yellow]‚ö†Ô∏è  Se alcanz√≥ el m√°ximo de iteraciones ({self.max_iteraciones})[/yellow]")
    
    def _mostrar_resultados(self):
        """Muestra los resultados del m√©todo"""
        console.print("\n[bold blue]üìä RESULTADOS[/bold blue]\n")
        
        if not self.resultados:
            console.print("[red]No hay resultados para mostrar[/red]")
            return
            
        ultimo = self.resultados[-1]
        
        # Resumen de convergencia
        panel_resultado = Panel.fit(
            f"[bold green]Ra√≠z encontrada: {ultimo['c']:.8f}[/bold green]\n"
            f"[blue]Error absoluto: {ultimo['error_abs']:.2e}[/blue]\n"
            f"[blue]Error relativo: {ultimo['error_rel']:.2e}[/blue]\n"
            f"[blue]Iteraciones: {ultimo['iteracion']}[/blue]\n"
            f"[blue]f(ra√≠z) = {ultimo['fc']:.2e}[/blue]",
            title="üéØ Resultado Final",
            border_style="green"
        )
        console.print(panel_resultado)
        
        # Tabla de iteraciones (√∫ltimas 10)
        console.print("\n[bold blue]Tabla de Iteraciones (√∫ltimas 10):[/bold blue]")
        
        table = Table()
        table.add_column("Iter", style="cyan", width=4)
        table.add_column("a", style="blue", width=12)
        table.add_column("b", style="blue", width=12)
        table.add_column("c", style="yellow", width=12)
        table.add_column("f(c)", style="green", width=12)
        table.add_column("Error Abs", style="red", width=10)
        
        # Mostrar √∫ltimas 10 iteraciones
        ultimas = self.resultados[-10:] if len(self.resultados) > 10 else self.resultados
        
        for r in ultimas:
            table.add_row(
                str(r['iteracion']),
                f"{r['a']:.6f}",
                f"{r['b']:.6f}",
                f"{r['c']:.6f}",
                f"{r['fc']:.2e}",
                f"{r['error_abs']:.2e}"
            )
            
        console.print(table)
        
        # Mostrar gr√°ficos
        self._mostrar_graficos_convergencia()
    
    def _mostrar_grafico_intervalo(self):
        """Muestra gr√°fico de la funci√≥n en el intervalo"""
        try:
            margin = 0.2 * (self.b - self.a)
            x_plot = np.linspace(self.a - margin, self.b + margin, 1000)
            y_plot = [self.funcion_numpy(x) for x in x_plot]
            
            plt.figure(figsize=(10, 6))
            plt.plot(x_plot, y_plot, 'b-', linewidth=2, label=f'f(x) = {self.funcion_str}')
            plt.axhline(y=0, color='k', linestyle='--', alpha=0.3)
            plt.axvline(x=self.a, color='r', linestyle='--', alpha=0.7, label=f'a = {self.a}')
            plt.axvline(x=self.b, color='r', linestyle='--', alpha=0.7, label=f'b = {self.b}')
            
            # Marcar puntos de evaluaci√≥n
            plt.plot(self.a, self.funcion_numpy(self.a), 'ro', markersize=8, label=f'f(a) = {self.funcion_numpy(self.a):.4f}')
            plt.plot(self.b, self.funcion_numpy(self.b), 'ro', markersize=8, label=f'f(b) = {self.funcion_numpy(self.b):.4f}')
            
            plt.title('Funci√≥n en el Intervalo de B√∫squeda')
            plt.xlabel('x')
            plt.ylabel('f(x)')
            plt.grid(True, alpha=0.3)
            plt.legend()
            plt.tight_layout()
            plt.show()
            
        except Exception as e:
            console.print(f"[yellow]‚ö†Ô∏è  No se pudo mostrar el gr√°fico: {str(e)}[/yellow]")
    
    def _mostrar_graficos_convergencia(self):
        """Muestra gr√°ficos de convergencia"""
        if len(self.resultados) < 2:
            return
            
        try:
            # Extraer datos
            iteraciones = [r['iteracion'] for r in self.resultados]
            aproximaciones = [r['c'] for r in self.resultados]
            errores_abs = [r['error_abs'] for r in self.resultados]
            errores_rel = [r['error_rel'] for r in self.resultados if r['error_rel'] != float('inf')]
            
            # Crear subplots
            fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 10))
            
            # Gr√°fico 1: Convergencia de aproximaciones
            ax1.plot(iteraciones, aproximaciones, 'bo-', linewidth=2, markersize=4)
            ax1.set_xlabel('Iteraci√≥n')
            ax1.set_ylabel('Aproximaci√≥n de la ra√≠z')
            ax1.set_title('Convergencia de Aproximaciones')
            ax1.grid(True, alpha=0.3)
            
            # Gr√°fico 2: Error absoluto
            ax2.semilogy(iteraciones, errores_abs, 'ro-', linewidth=2, markersize=4)
            ax2.set_xlabel('Iteraci√≥n')
            ax2.set_ylabel('Error Absoluto (log)')
            ax2.set_title('Convergencia del Error Absoluto')
            ax2.grid(True, alpha=0.3)
            
            # Gr√°fico 3: Longitud del intervalo
            longitudes = [r['longitud_intervalo'] for r in self.resultados]
            ax3.semilogy(iteraciones, longitudes, 'go-', linewidth=2, markersize=4)
            ax3.set_xlabel('Iteraci√≥n')
            ax3.set_ylabel('Longitud del Intervalo (log)')
            ax3.set_title('Reducci√≥n del Intervalo')
            ax3.grid(True, alpha=0.3)
            
            # Gr√°fico 4: Funci√≥n en la ra√≠z
            valores_funcion = [abs(r['fc']) for r in self.resultados]
            ax4.semilogy(iteraciones, valores_funcion, 'mo-', linewidth=2, markersize=4)
            ax4.set_xlabel('Iteraci√≥n')
            ax4.set_ylabel('|f(c)| (log)')
            ax4.set_title('Valor de la Funci√≥n en c')
            ax4.grid(True, alpha=0.3)
            
            plt.tight_layout()
            plt.show()
            
        except Exception as e:
            console.print(f"[yellow]‚ö†Ô∏è  No se pudieron mostrar los gr√°ficos: {str(e)}[/yellow]")
    
    def ver_resultados_anteriores(self):
        """Muestra resultados de ejecuciones anteriores"""
        self.limpiar_pantalla()
        console.print("[bold blue]üìà RESULTADOS ANTERIORES[/bold blue]\n")
        
        if not self.resultados:
            console.print("[yellow]No hay resultados anteriores para mostrar[/yellow]")
            console.print("Ejecute el m√©todo primero.")
            input("\nPresione Enter para continuar...")
            return
            
        self._mostrar_resultados()
        input("\nPresione Enter para continuar...")
    
    def mostrar_ayuda(self):
        """Muestra ayuda del m√©todo"""
        self.limpiar_pantalla()
        console.print("[bold blue]‚ùì AYUDA - M√âTODO DE BISECCI√ìN[/bold blue]\n")
        
        ayuda_texto = """
[bold cyan]¬øQu√© es el m√©todo de bisecci√≥n?[/bold cyan]
Es un m√©todo num√©rico para encontrar ra√≠ces de ecuaciones no lineales.
Funciona dividiendo repetidamente un intervalo por la mitad hasta
encontrar la ra√≠z con la precisi√≥n deseada.

[bold cyan]¬øCu√°ndo usarlo?[/bold cyan]
‚Ä¢ Cuando tienes una funci√≥n continua f(x)
‚Ä¢ Conoces un intervalo [a,b] donde f(a) y f(b) tienen signos opuestos
‚Ä¢ Necesitas un m√©todo garantizado de convergencia
‚Ä¢ No tienes la derivada de la funci√≥n

[bold cyan]Pasos para usar este programa:[/bold cyan]
1. Ingrese la funci√≥n f(x) usando sintaxis de Python
2. Configure el intervalo [a,b] donde buscar la ra√≠z
3. Ajuste la tolerancia y m√°ximo de iteraciones si es necesario
4. Execute el m√©todo y analice los resultados

[bold cyan]Ejemplos de funciones v√°lidas:[/bold cyan]
‚Ä¢ x**2 - 4                    (ra√≠ces en ¬±2)
‚Ä¢ exp(x) - 2                  (ra√≠z en ln(2))
‚Ä¢ sin(x) - 0.5                (ra√≠z en œÄ/6)
‚Ä¢ x**3 - 2*x - 5              (ecuaci√≥n c√∫bica)
‚Ä¢ log(x) + x - 2              (ecuaci√≥n trascendental)

[bold cyan]Funciones disponibles:[/bold cyan]
‚Ä¢ B√°sicas: +, -, *, /, **
‚Ä¢ Trigonom√©tricas: sin, cos, tan, asin, acos, atan
‚Ä¢ Exponenciales: exp, log (natural), log10
‚Ä¢ Hiperb√≥licas: sinh, cosh, tanh
‚Ä¢ Otras: sqrt, abs

[bold cyan]Consejos:[/bold cyan]
‚Ä¢ Grafique la funci√≥n primero para identificar intervalos prometedores
‚Ä¢ Use par√©ntesis para clarificar el orden de operaciones
‚Ä¢ Si f(a) y f(b) tienen el mismo signo, intente otro intervalo
‚Ä¢ Para mayor precisi√≥n, reduzca la tolerancia
‚Ä¢ Para convergencia m√°s r√°pida, elija un intervalo m√°s peque√±o
        """
        
        console.print(ayuda_texto)
        input("\nPresione Enter para continuar...")

def main():
    """Funci√≥n principal"""
    metodo = MetodoBiseccion()
    
    while True:
        opcion = metodo.mostrar_menu_principal()
        
        if opcion == "1":
            metodo.ingresar_funcion()
        elif opcion == "2":
            metodo.configurar_intervalo()
        elif opcion == "3":
            metodo.configurar_parametros()
        elif opcion == "4":
            metodo.ejecutar_metodo()
        elif opcion == "5":
            metodo.ver_resultados_anteriores()
        elif opcion == "6":
            metodo.mostrar_ayuda()
        elif opcion == "7":
            console.print("\n[green]¬°Gracias por usar el M√©todo de Bisecci√≥n![/green]")
            break

if __name__ == "__main__":
    main()
```

# Interfaz de Usuario

El programa presenta una interfaz CLI elegante con las siguientes caracter√≠sticas:

## Men√∫ Principal
- **Opciones numeradas**: 1-7 para navegaci√≥n intuitiva
- **Rich formatting**: Colores y estilos para mejor legibilidad
- **Descripci√≥n clara**: Cada opci√≥n explica su funci√≥n

## Flujo de Uso
1. **Ingreso de funci√≥n**: Sintaxis Python con validaci√≥n autom√°tica
2. **Configuraci√≥n de intervalo**: Verificaci√≥n de condiciones del teorema
3. **Par√°metros ajustables**: Tolerancia e iteraciones m√°ximas
4. **Ejecuci√≥n visual**: Barra de progreso con tqdm
5. **Resultados completos**: Tablas, gr√°ficos y an√°lisis

## Validaciones
- Sintaxis correcta de la funci√≥n
- Continuidad en el intervalo
- Signos opuestos en los extremos
- Valores num√©ricos v√°lidos

# Ejemplos de Ejecuci√≥n

## Ejemplo 1: Funci√≥n Cuadr√°tica
```
Funci√≥n: x**2 - 4
Intervalo: [1, 3]
Tolerancia: 1e-6

Resultado: x = 2.000000
Iteraciones: 20
```

## Ejemplo 2: Funci√≥n Exponencial
```
Funci√≥n: exp(x) - 2
Intervalo: [0, 1]
Tolerancia: 1e-8

Resultado: x = 0.69314718 (ln(2))
Iteraciones: 27
```

## Ejemplo 3: Funci√≥n Trascendental
```
Funci√≥n: sin(x) - 0.5
Intervalo: [0, 1]
Tolerancia: 1e-10

Resultado: x = 0.5235987756 (œÄ/6)
Iteraciones: 33
```

# Visualizaciones

El programa genera autom√°ticamente:

1. **Gr√°fico del intervalo**: Muestra la funci√≥n y los puntos de evaluaci√≥n
2. **Convergencia de aproximaciones**: Evoluci√≥n de las estimaciones de la ra√≠z
3. **Error absoluto**: Reducci√≥n del error en escala logar√≠tmica
4. **Longitud del intervalo**: Bisecci√≥n progresiva del intervalo
5. **Valor de la funci√≥n**: |f(c)| para verificar convergencia a cero

Todos los gr√°ficos se muestran en tiempo real usando matplotlib con ventanas emergentes.

# Ideas de Mejora

## Funcionalidades Adicionales
- **M√∫ltiples intervalos**: B√∫squeda autom√°tica de intervalos v√°lidos
- **Comparaci√≥n de m√©todos**: Bisecci√≥n vs. otros m√©todos
- **An√°lisis de sensibilidad**: Efecto de cambios en par√°metros
- **Exportaci√≥n de datos**: Guardar resultados en CSV/Excel
- **Funciones predefinidas**: Biblioteca de ejemplos comunes

## Optimizaciones de Rendimiento
- **Evaluaci√≥n vectorizada**: NumPy para m√∫ltiples puntos
- **Cach√© de resultados**: Evitar rec√°lculos innecesarios
- **Precisi√≥n adaptiva**: Ajuste autom√°tico de tolerancia
- **Paralelizaci√≥n**: M√∫ltiples b√∫squedas simult√°neas

## Mejoras de Interfaz
- **Gr√°ficos interactivos**: Plotly en lugar de matplotlib
- **Interfaz web**: Flask/Streamlit para uso en navegador
- **Guardar sesiones**: Persistencia de configuraciones
- **Historial completo**: Base de datos de ejecuciones

# Complicaciones Encontradas

## Desaf√≠os de Implementaci√≥n

### 1. Validaci√≥n de Funciones
**Problema**: Evaluaci√≥n segura de funciones ingresadas por el usuario
**Soluci√≥n**: Combinaci√≥n de SymPy para parsing y NumPy para evaluaci√≥n num√©rica

### 2. Manejo de Dominios
**Problema**: Funciones no definidas en ciertos puntos (log(0), 1/0)
**Soluci√≥n**: Try-catch en evaluaciones con mensajes informativos

### 3. Convergencia Lenta
**Problema**: El m√©todo puede requerir muchas iteraciones
**Soluci√≥n**: Estimaci√≥n autom√°tica del n√∫mero de iteraciones necesarias

### 4. Casos Edge
**Problema**: Intervalos muy peque√±os o muy grandes
**Soluci√≥n**: Validaci√≥n de rangos num√©ricos y warning para condicionamiento

### 5. Visualizaci√≥n en Tiempo Real
**Problema**: Mostrar gr√°ficos sin bloquear la ejecuci√≥n
**Soluci√≥n**: Matplotlib con modo no-bloqueante y manejo de excepciones

## Casos Especiales Manejados
- Funciones con discontinuidades
- Ra√≠ces m√∫ltiples en el intervalo
- Funciones con derivadas muy peque√±as
- Problemas de precisi√≥n num√©rica
- Intervalos iniciales inapropiados

# Manual de Uso

## Instalaci√≥n
```bash
# Clonar el repositorio
git clone [repositorio]

# Instalar dependencias
pip install -r requirements.txt

# Ejecutar el m√©todo
python ecuaciones_no_lineales/biseccion.py
```

## Uso Paso a Paso

### 1. Ejecutar el Programa
```bash
python ecuaciones_no_lineales/biseccion.py
```

### 2. Ingresar Funci√≥n (Opci√≥n 1)
- Escriba la funci√≥n usando sintaxis Python
- Ejemplo: `x**3 - 2*x - 5`
- Use funciones como `sin`, `cos`, `exp`, `log`

### 3. Configurar Intervalo (Opci√≥n 2)
- Ingrese extremo izquierdo `a`
- Ingrese extremo derecho `b`
- Verifique que f(a) y f(b) tengan signos opuestos

### 4. Ajustar Par√°metros (Opci√≥n 3)
- **Tolerancia**: Error m√°ximo aceptable (default: 1e-6)
- **Max. iteraciones**: L√≠mite de iteraciones (default: 100)

### 5. Ejecutar M√©todo (Opci√≥n 4)
- Revise la configuraci√≥n mostrada
- Confirme la ejecuci√≥n
- Observe la barra de progreso
- Analice los resultados y gr√°ficos

### 6. Analizar Resultados
- **Valor de la ra√≠z**: Aproximaci√≥n encontrada
- **Error**: Precisi√≥n alcanzada
- **Iteraciones**: N√∫mero de pasos realizados
- **Gr√°ficos**: Visualizaci√≥n de la convergencia

## Soluci√≥n de Problemas

### Error: "Funci√≥n no v√°lida"
- Revise la sintaxis Python
- Use `**` para potencias, no `^`
- Verifique nombres de funciones (sin, cos, etc.)

### Error: "Signos iguales en extremos"
- La funci√≥n no cambia de signo en [a,b]
- Intente un intervalo diferente
- Grafique la funci√≥n para identificar ra√≠ces

### Convergencia lenta
- Reduzca el tama√±o del intervalo inicial
- Aumente el m√°ximo de iteraciones
- Considere usar otro m√©todo m√°s r√°pido

### Resultado impreciso
- Reduzca la tolerancia
- Verifique que la funci√≥n sea continua
- Aseg√∫rese de que hay una sola ra√≠z en el intervalo

---

*Documentaci√≥n generada para el Proyecto de M√©todos Num√©ricos*  
*Ingenier√≠a en Computaci√≥n - Uso Educativo*
