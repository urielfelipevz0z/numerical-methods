---
title: "M√©todo de Newton-Raphson"
author: "Proyecto Personal - Ingenier√≠a en Computaci√≥n"  
date: today
format: 
  html:
    theme: cosmo
    code-fold: true
    toc: true
    number-sections: true
    highlight-style: github
    fig-width: 10
    fig-height: 6
    embed-resources: true
execute:
  warning: false
  echo: true
---

# ¬øPara qu√© sirve?

El m√©todo de Newton-Raphson es uno de los algoritmos m√°s poderosos para encontrar ra√≠ces de ecuaciones no lineales. Su convergencia cuadr√°tica lo convierte en la opci√≥n preferida cuando se requiere alta precisi√≥n y rapidez.

## Aplicaciones Pr√°cticas

- **Ingenier√≠a estructural**: An√°lisis no lineal de estructuras y c√°lculo de cargas cr√≠ticas
- **Procesamiento de se√±ales**: Filtros adaptativos y estimaci√≥n de par√°metros
- **Econom√≠a computacional**: Optimizaci√≥n de carteras y modelos de equilibrio
- **F√≠sica computacional**: Resoluci√≥n de ecuaciones de estado y mec√°nica cu√°ntica
- **An√°lisis num√©rico**: Base para m√©todos de optimizaci√≥n y sistemas no lineales

## Casos de Uso Espec√≠ficos

1. **Ecuaciones trascendentales complejas**: $e^x \cos(x) - x^2 = 0$
2. **Ra√≠ces de polinomios de alto grado**: Localizaci√≥n de ra√≠ces m√∫ltiples
3. **Problemas de ingenier√≠a**: C√°lculo de frecuencias naturales, an√°lisis de circuitos
4. **M√©todos h√≠bridos**: Combinaci√≥n con bisecci√≥n para garantizar convergencia
5. **Optimizaci√≥n**: Encontrar puntos cr√≠ticos de funciones objetivo

# ¬øC√≥mo funciona?

## Fundamento Te√≥rico

El m√©todo utiliza la aproximaci√≥n lineal de Taylor para la funci√≥n en cada iteraci√≥n:

$$f(x) \approx f(x_n) + f'(x_n)(x - x_n)$$

Igualando a cero y resolviendo para $x$:

$$x_{n+1} = x_n - \frac{f(x_n)}{f'(x_n)}$$

## Interpretaci√≥n Geom√©trica

1. **L√≠nea tangente**: En cada punto $(x_n, f(x_n))$, se traza la tangente
2. **Intersecci√≥n**: Se encuentra donde la tangente cruza el eje X
3. **Nueva aproximaci√≥n**: Ese punto se convierte en $x_{n+1}$
4. **Iteraci√≥n**: Se repite el proceso hasta convergencia

## Algoritmo Paso a Paso

```
1. INICIO
2. Definir f(x) y calcular f'(x) (derivada)
3. Establecer x‚ÇÄ (valor inicial)
4. Establecer tolerancia Œµ y m√°ximo de iteraciones N
5. Para n = 0, 1, 2, ..., N:
   a. Calcular f(x‚Çô) y f'(x‚Çô)
   b. Verificar si f'(x‚Çô) ‚âà 0 (derivada nula)
   c. Calcular x_{n+1} = x‚Çô - f(x‚Çô)/f'(x‚Çô)
   d. Verificar convergencia: |x_{n+1} - x‚Çô| < Œµ
   e. Si converge: TERMINAR con √©xito
6. Si se alcanza N iteraciones: TERMINAR sin convergencia
7. FIN
```

## Convergencia Cuadr√°tica

Bajo condiciones favorables:
- $|e_{n+1}| \approx C|e_n|^2$ donde $e_n = x_n - x^*$
- El n√∫mero de d√≠gitos correctos se duplica en cada iteraci√≥n
- Convergencia extremadamente r√°pida cerca de la soluci√≥n

# Implementaci√≥n Completa

```{python}
#!/usr/bin/env python3
"""
M√©todo de Newton-Raphson - Implementaci√≥n con men√∫s interactivos
Convergencia cuadr√°tica para encontrar ra√≠ces de ecuaciones no lineales
"""

import numpy as np
import matplotlib.pyplot as plt
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import track
import sympy as sp
from typing import Callable, Tuple, List, Optional
import os

console = Console()

class MetodoNewtonRaphson:
    """Implementaci√≥n del m√©todo de Newton-Raphson con interfaz interactiva"""
    
    def __init__(self):
        self.funcion_str = ""
        self.funcion_sympy = None
        self.funcion_numpy = None
        self.derivada_sympy = None
        self.derivada_numpy = None
        self.x0 = 0.0
        self.tolerancia = 1e-10
        self.max_iteraciones = 50
        self.resultados = []
        self.metodo_derivada = "simbolica"  # "simbolica", "numerica", "manual"
        
    def limpiar_pantalla(self):
        """Limpia la pantalla del terminal"""
        os.system('clear' if os.name == 'posix' else 'cls')
        
    def mostrar_banner(self):
        """Muestra el banner del m√©todo"""
        banner = Panel.fit(
            "[bold blue]‚ö° M√âTODO DE NEWTON-RAPHSON[/bold blue]\n"
            "[italic]Convergencia cuadr√°tica mediante aproximaci√≥n tangente[/italic]",
            border_style="blue"
        )
        console.print(banner)
        console.print()
    
    def mostrar_menu_principal(self) -> str:
        """Muestra el men√∫ principal y retorna la opci√≥n seleccionada"""
        self.limpiar_pantalla()
        self.mostrar_banner()
        
        table = Table(show_header=False, box=None, padding=(0, 2))
        table.add_column("Opci√≥n", style="bold cyan", width=8)
        table.add_column("Descripci√≥n", style="white")
        
        opciones = [
            ("1", "üéØ Ingresar funci√≥n f(x)"),
            ("2", "üìê Configurar derivada f'(x)"),
            ("3", "üìç Configurar valor inicial x‚ÇÄ"),
            ("4", "‚öôÔ∏è  Configurar par√°metros"),
            ("5", "üöÄ Ejecutar Newton-Raphson"),
            ("6", "üìä Ver resultados"),
            ("7", "üìà An√°lisis de convergencia"),
            ("8", "üîç An√°lisis de derivada"),
            ("9", "‚ùì Ayuda"),
            ("10", "üö™ Salir")
        ]
        
        for opcion, desc in opciones:
            table.add_row(opcion, desc)
        
        console.print(table)
        return input("\nüîπ Seleccione una opci√≥n: ").strip()
    
    def ingresar_funcion(self):
        """Permite al usuario ingresar la funci√≥n f(x)"""
        self.limpiar_pantalla()
        
        panel_ayuda = Panel(
            "[bold cyan]Ingrese la funci√≥n f(x) = 0[/bold cyan]\n\n"
            "Ejemplos v√°lidos:\n"
            "‚Ä¢ x**3 - 2*x - 5\n"
            "‚Ä¢ sin(x) - 0.5\n"
            "‚Ä¢ exp(x) - 3*x\n"
            "‚Ä¢ x**2 - cos(x)\n"
            "‚Ä¢ log(x) - x + 2\n\n"
            "[yellow]Funciones disponibles:[/yellow]\n"
            "sin, cos, tan, exp, log, ln, sqrt, abs\n\n"
            "[green]üí° Newton-Raphson requiere que f'(x) ‚â† 0 en la soluci√≥n[/green]",
            title="üí° Ayuda para Funciones",
            border_style="blue"
        )
        console.print(panel_ayuda)
        
        while True:
            try:
                funcion_input = input("\nIngrese f(x): ").strip()
                
                if not funcion_input:
                    console.print("[red]‚ùå La funci√≥n no puede estar vac√≠a[/red]")
                    continue
                
                # Procesar la funci√≥n con SymPy
                x = sp.Symbol('x')
                funcion_input = funcion_input.replace('^', '**')
                self.funcion_sympy = sp.sympify(funcion_input)
                self.funcion_numpy = sp.lambdify(x, self.funcion_sympy, 'numpy')
                self.funcion_str = funcion_input
                
                # Calcular derivada simb√≥lica autom√°ticamente
                try:
                    self.derivada_sympy = sp.diff(self.funcion_sympy, x)
                    self.derivada_numpy = sp.lambdify(x, self.derivada_sympy, 'numpy')
                    
                    console.print(f"\n[green]‚úÖ Funci√≥n ingresada: f(x) = {funcion_input}[/green]")
                    console.print(f"[blue]üìê Derivada calculada: f'(x) = {self.derivada_sympy}[/blue]")
                    
                except Exception as e:
                    console.print(f"\n[green]‚úÖ Funci√≥n ingresada: f(x) = {funcion_input}[/green]")
                    console.print(f"[yellow]‚ö†Ô∏è  No se pudo calcular la derivada autom√°ticamente: {e}[/yellow]")
                    console.print("[yellow]Podr√° ingresarla manualmente en el siguiente men√∫[/yellow]")
                
                # Probar la funci√≥n en algunos puntos
                console.print("\n[cyan]Valores de prueba:[/cyan]")
                test_table = Table(title="Evaluaci√≥n de f(x)")
                test_table.add_column("x", justify="center", style="cyan")
                test_table.add_column("f(x)", justify="center", style="green")
                
                if self.derivada_numpy:
                    test_table.add_column("f'(x)", justify="center", style="yellow")
                
                for val in [0, 1, -1, 0.5, 2]:
                    try:
                        f_val = float(self.funcion_numpy(val))
                        if self.derivada_numpy:
                            try:
                                df_val = float(self.derivada_numpy(val))
                                test_table.add_row(str(val), f"{f_val:.6f}", f"{df_val:.6f}")
                            except:
                                test_table.add_row(str(val), f"{f_val:.6f}", "No definida")
                        else:
                            test_table.add_row(str(val), f"{f_val:.6f}")
                    except:
                        if self.derivada_numpy:
                            test_table.add_row(str(val), "No definida", "No definida")
                        else:
                            test_table.add_row(str(val), "No definida")
                        
                console.print(test_table)
                break
                
            except Exception as e:
                console.print(f"[red]‚ùå Error en la funci√≥n: {str(e)}[/red]")
                console.print("Revise la sintaxis. Use 'exp', 'sin', 'cos', 'log', etc.")
                
        input("\nPresione Enter para continuar...")
    
    def configurar_derivada(self):
        """Configura el m√©todo para calcular la derivada"""
        if not self.funcion_sympy:
            console.print("[red]‚ùå Debe ingresar una funci√≥n primero[/red]")
            input("Presione Enter para continuar...")
            return
        
        self.limpiar_pantalla()
        console.print("[bold blue]üìê CONFIGURACI√ìN DE DERIVADA[/bold blue]\n")
        
        console.print("Elija c√≥mo calcular f'(x):")
        console.print("1. üî¢ Derivada simb√≥lica (autom√°tica)")
        console.print("2. üìù Ingresar derivada manualmente")
        console.print("3. üßÆ Derivada num√©rica (diferencias finitas)")
        console.print("4. üîô Volver al men√∫ principal")
        
        while True:
            try:
                opcion = input("\nSeleccione opci√≥n (1-4): ").strip()
                
                if opcion == "1":
                    try:
                        x = sp.Symbol('x')
                        self.derivada_sympy = sp.diff(self.funcion_sympy, x)
                        self.derivada_numpy = sp.lambdify(x, self.derivada_sympy, 'numpy')
                        self.metodo_derivada = "simbolica"
                        
                        console.print(f"\n[green]‚úÖ Derivada simb√≥lica: f'(x) = {self.derivada_sympy}[/green]")
                        
                    except Exception as e:
                        console.print(f"[red]‚ùå Error al calcular derivada: {e}[/red]")
                        continue
                        
                elif opcion == "2":
                    derivada_input = input("\nIngrese f'(x): ").strip()
                    
                    if not derivada_input:
                        console.print("[red]‚ùå La derivada no puede estar vac√≠a[/red]")
                        continue
                    
                    try:
                        x = sp.Symbol('x')
                        derivada_input = derivada_input.replace('^', '**')
                        self.derivada_sympy = sp.sympify(derivada_input)
                        self.derivada_numpy = sp.lambdify(x, self.derivada_sympy, 'numpy')
                        self.metodo_derivada = "manual"
                        
                        console.print(f"\n[green]‚úÖ Derivada manual: f'(x) = {derivada_input}[/green]")
                        
                    except Exception as e:
                        console.print(f"[red]‚ùå Error en la derivada: {e}[/red]")
                        continue
                        
                elif opcion == "3":
                    self.metodo_derivada = "numerica"
                    self.derivada_numpy = self._derivada_numerica
                    console.print("\n[green]‚úÖ Usando derivada num√©rica (diferencias finitas)[/green]")
                    console.print("[yellow]h = 1e-8 por defecto[/yellow]")
                    
                elif opcion == "4":
                    return
                else:
                    console.print("[red]‚ùå Opci√≥n inv√°lida[/red]")
                    continue
                
                # Probar la derivada
                if self.derivada_numpy:
                    console.print("\n[cyan]Valores de prueba de f'(x):[/cyan]")
                    test_table = Table(title="Evaluaci√≥n de f'(x)")
                    test_table.add_column("x", justify="center", style="cyan")
                    test_table.add_column("f'(x)", justify="center", style="yellow")
                    
                    for val in [0, 1, -1, 0.5]:
                        try:
                            df_val = float(self.derivada_numpy(val))
                            test_table.add_row(str(val), f"{df_val:.6f}")
                        except:
                            test_table.add_row(str(val), "No definida")
                    
                    console.print(test_table)
                
                break
                
            except Exception as e:
                console.print(f"[red]‚ùå Error: {e}[/red]")
        
        input("\nPresione Enter para continuar...")
    
    def _derivada_numerica(self, x, h=1e-8):
        """Calcula derivada num√©rica usando diferencias centrales"""
        try:
            return (self.funcion_numpy(x + h) - self.funcion_numpy(x - h)) / (2 * h)
        except:
            # Si falla diferencias centrales, usar diferencias hacia adelante
            return (self.funcion_numpy(x + h) - self.funcion_numpy(x)) / h
    
    def configurar_valor_inicial(self):
        """Configura el valor inicial x‚ÇÄ"""
        self.limpiar_pantalla()
        console.print("[bold blue]üìç CONFIGURACI√ìN DEL VALOR INICIAL[/bold blue]\n")
        
        if self.funcion_numpy:
            console.print("üí° Sugerencia: Use gr√°ficos o estimaciones para elegir x‚ÇÄ cerca de la ra√≠z")
            
            # Mostrar algunos valores para ayudar al usuario
            console.print("\n[cyan]Valores de f(x) en algunos puntos:[/cyan]")
            test_table = Table()
            test_table.add_column("x", justify="center", style="cyan")
            test_table.add_column("f(x)", justify="center", style="green")
            
            for val in [-2, -1, 0, 1, 2]:
                try:
                    f_val = float(self.funcion_numpy(val))
                    color = "red" if f_val > 0 else "blue"
                    test_table.add_row(str(val), f"[{color}]{f_val:.6f}[/{color}]")
                except:
                    test_table.add_row(str(val), "No definida")
            
            console.print(test_table)
            console.print("\n[yellow]üí° Busque cambios de signo para localizar ra√≠ces[/yellow]")
        
        while True:
            try:
                x0_input = input(f"\nIngrese x‚ÇÄ (actual: {self.x0}): ").strip()
                
                if x0_input:
                    self.x0 = float(x0_input)
                    
                    # Evaluar funci√≥n y derivada en x‚ÇÄ
                    if self.funcion_numpy and self.derivada_numpy:
                        try:
                            f_x0 = self.funcion_numpy(self.x0)
                            df_x0 = self.derivada_numpy(self.x0)
                            
                            console.print(f"\n[green]‚úÖ x‚ÇÄ = {self.x0}[/green]")
                            console.print(f"[cyan]f(x‚ÇÄ) = {f_x0:.6f}[/cyan]")
                            console.print(f"[yellow]f'(x‚ÇÄ) = {df_x0:.6f}[/yellow]")
                            
                            if abs(df_x0) < 1e-10:
                                console.print("[red]‚ö†Ô∏è  f'(x‚ÇÄ) ‚âà 0. Newton-Raphson puede no converger.[/red]")
                            else:
                                primera_aprox = self.x0 - f_x0/df_x0
                                console.print(f"[green]Primera aproximaci√≥n: x‚ÇÅ ‚âà {primera_aprox:.6f}[/green]")
                                
                        except Exception as e:
                            console.print(f"\n[green]‚úÖ x‚ÇÄ = {self.x0}[/green]")
                            console.print(f"[red]‚ö†Ô∏è  Error al evaluar: {e}[/red]")
                    else:
                        console.print(f"\n[green]‚úÖ x‚ÇÄ = {self.x0}[/green]")
                else:
                    console.print(f"\n[green]‚úÖ Manteniendo x‚ÇÄ = {self.x0}[/green]")
                
                break
                
            except ValueError:
                console.print("[red]‚ùå Por favor ingrese un n√∫mero v√°lido[/red]")
        
        input("\nPresione Enter para continuar...")
    
    def configurar_parametros(self):
        """Configura tolerancia y n√∫mero m√°ximo de iteraciones"""
        self.limpiar_pantalla()
        console.print("[bold blue]‚öôÔ∏è CONFIGURACI√ìN DE PAR√ÅMETROS[/bold blue]\n")
        
        # Mostrar configuraci√≥n actual
        config_table = Table(title="Configuraci√≥n Actual")
        config_table.add_column("Par√°metro", style="cyan")
        config_table.add_column("Valor", style="green")
        
        config_table.add_row("Tolerancia", f"{self.tolerancia}")
        config_table.add_row("M√°x. iteraciones", f"{self.max_iteraciones}")
        config_table.add_row("M√©todo derivada", self.metodo_derivada.capitalize())
        
        console.print(config_table)
        
        # Configurar tolerancia
        console.print("\n[yellow]üí° Newton-Raphson permite tolerancias muy peque√±as (ej: 1e-10)[/yellow]")
        while True:
            try:
                tol_input = input(f"\nNueva tolerancia (actual: {self.tolerancia}): ").strip()
                if tol_input:
                    nueva_tol = float(tol_input)
                    if nueva_tol <= 0:
                        console.print("[red]‚ùå La tolerancia debe ser positiva[/red]")
                        continue
                    self.tolerancia = nueva_tol
                    console.print(f"[green]‚úÖ Tolerancia actualizada: {nueva_tol}[/green]")
                break
            except ValueError:
                console.print("[red]‚ùå Ingrese un n√∫mero v√°lido[/red]")
        
        # Configurar m√°ximo de iteraciones
        console.print("\n[yellow]üí° Newton-Raphson t√≠picamente converge en pocas iteraciones[/yellow]")
        while True:
            try:
                iter_input = input(f"Nuevo m√°ximo de iteraciones (actual: {self.max_iteraciones}): ").strip()
                if iter_input:
                    nuevo_max = int(iter_input)
                    if nuevo_max <= 0:
                        console.print("[red]‚ùå El n√∫mero de iteraciones debe ser positivo[/red]")
                        continue
                    self.max_iteraciones = nuevo_max
                    console.print(f"[green]‚úÖ M√°ximo de iteraciones actualizado: {nuevo_max}[/green]")
                break
            except ValueError:
                console.print("[red]‚ùå Ingrese un n√∫mero entero v√°lido[/red]")
        
        input("\nPresione Enter para continuar...")
    
    def ejecutar_metodo(self):
        """Ejecuta el m√©todo de Newton-Raphson"""
        if not self.funcion_numpy or not self.derivada_numpy:
            console.print("[red]‚ùå Debe configurar funci√≥n y derivada primero[/red]")
            input("Presione Enter para continuar...")
            return
        
        self.limpiar_pantalla()
        console.print("[bold blue]üöÄ EJECUTANDO NEWTON-RAPHSON[/bold blue]\n")
        
        # Mostrar configuraci√≥n
        console.print(f"Funci√≥n: f(x) = {self.funcion_str}")
        if self.metodo_derivada == "simbolica":
            console.print(f"Derivada: f'(x) = {self.derivada_sympy}")
        elif self.metodo_derivada == "manual":
            console.print(f"Derivada: f'(x) = {self.derivada_sympy}")
        else:
            console.print("Derivada: Num√©rica (diferencias finitas)")
        console.print(f"Valor inicial: x‚ÇÄ = {self.x0}")
        console.print(f"Tolerancia: {self.tolerancia}")
        console.print(f"M√°x. iteraciones: {self.max_iteraciones}\n")
        
        # Inicializar
        self.resultados = []
        x_actual = self.x0
        
        console.print("Iniciando iteraciones...\n")
        
        # Crear tabla para mostrar iteraciones
        tabla_iter = Table(title="Iteraciones del M√©todo de Newton-Raphson")
        tabla_iter.add_column("n", justify="center", style="cyan")
        tabla_iter.add_column("x‚Çô", justify="center", style="green")
        tabla_iter.add_column("f(x‚Çô)", justify="center", style="yellow")
        tabla_iter.add_column("f'(x‚Çô)", justify="center", style="blue")
        tabla_iter.add_column("x‚Çô‚Çä‚ÇÅ", justify="center", style="magenta")
        tabla_iter.add_column("Error", justify="center", style="red")
        
        # Iteraciones
        for i in range(self.max_iteraciones):
            try:
                # Evaluar funci√≥n y derivada
                f_x = self.funcion_numpy(x_actual)
                df_x = self.derivada_numpy(x_actual)
                
                # Verificar derivada nula
                if abs(df_x) < 1e-15:
                    console.print(f"\n[red]üí• f'(x) ‚âà 0 en x = {x_actual:.8f}[/red]")
                    console.print("[red]No se puede continuar (divisi√≥n por cero)[/red]")
                    break
                
                # Calcular siguiente aproximaci√≥n
                x_siguiente = x_actual - f_x / df_x
                
                # Calcular error
                error = abs(x_siguiente - x_actual)
                
                # Guardar resultado
                self.resultados.append({
                    'iteracion': i,
                    'x': x_actual,
                    'f_x': f_x,
                    'df_x': df_x,
                    'x_siguiente': x_siguiente,
                    'error': error
                })
                
                # Mostrar en tabla (primeras 10 iteraciones)
                if i < 10:
                    tabla_iter.add_row(
                        str(i),
                        f"{x_actual:.8f}",
                        f"{f_x:.2e}",
                        f"{df_x:.2e}",
                        f"{x_siguiente:.8f}",
                        f"{error:.2e}"
                    )
                
                # Verificar convergencia
                if error < self.tolerancia:
                    console.print(f"\n[green]üéâ ¬°Convergencia alcanzada en {i+1} iteraciones![/green]")
                    console.print(f"[green]Ra√≠z encontrada: x* ‚âà {x_siguiente:.12f}[/green]")
                    console.print(f"[green]f(x*) ‚âà {self.funcion_numpy(x_siguiente):.2e}[/green]")
                    console.print(f"[green]Error final: {error:.2e}[/green]")
                    break
                
                # Verificar si el valor se vuelve muy grande
                if abs(x_siguiente) > 1e10:
                    console.print(f"\n[red]üí• El m√©todo est√° divergiendo (|x| > 10¬π‚Å∞)[/red]")
                    break
                
                x_actual = x_siguiente
                
            except Exception as e:
                console.print(f"\n[red]‚ùå Error durante la iteraci√≥n {i}: {str(e)}[/red]")
                break
        else:
            console.print(f"\n[yellow]‚ö†Ô∏è  Se alcanz√≥ el m√°ximo de iteraciones ({self.max_iteraciones})[/yellow]")
            console.print(f"[yellow]√öltima aproximaci√≥n: x ‚âà {x_actual:.12f}[/yellow]")
            console.print(f"[yellow]f(x) ‚âà {self.funcion_numpy(x_actual):.2e}[/yellow]")
            console.print(f"[yellow]Error estimado: {error:.2e}[/yellow]")
        
        # Mostrar tabla de iteraciones
        console.print(tabla_iter)
        
        if len(self.resultados) > 10:
            console.print(f"\n[blue]... y {len(self.resultados) - 10} iteraciones m√°s[/blue]")
        
        input("\nPresione Enter para continuar...")
    
    def ver_resultados(self):
        """Muestra los resultados detallados"""
        if not self.resultados:
            console.print("[red]‚ùå No hay resultados disponibles. Execute el m√©todo primero.[/red]")
            input("Presione Enter para continuar...")
            return
        
        self.limpiar_pantalla()
        console.print("[bold blue]üìä RESULTADOS DETALLADOS[/bold blue]\n")
        
        ultimo = self.resultados[-1]
        
        # Panel de resumen
        try:
            valor_funcion = self.funcion_numpy(ultimo['x_siguiente'])
        except:
            valor_funcion = "No evaluable"
            
        resumen = Panel(
            f"[bold green]Ra√≠z encontrada:[/bold green] x* ‚âà {ultimo['x_siguiente']:.12f}\n"
            f"[bold blue]Iteraciones realizadas:[/bold blue] {len(self.resultados)}\n"
            f"[bold yellow]Error final:[/bold yellow] {ultimo['error']:.2e}\n"
            f"[bold cyan]f(x*):[/bold cyan] {valor_funcion:.2e if isinstance(valor_funcion, float) else valor_funcion}\n"
            f"[bold magenta]M√©todo derivada:[/bold magenta] {self.metodo_derivada.capitalize()}",
            title="üìã Resumen de Resultados",
            border_style="green"
        )
        console.print(resumen)
        
        # An√°lisis de convergencia cuadr√°tica
        if len(self.resultados) > 2:
            console.print("\n[bold blue]üìà An√°lisis de Convergencia Cuadr√°tica:[/bold blue]")
            
            errores = [r['error'] for r in self.resultados[1:]]
            
            # Verificar convergencia cuadr√°tica
            if len(errores) > 2:
                razones_cuadraticas = []
                for i in range(2, min(len(errores), 8)):
                    if errores[i-1] != 0 and errores[i-2] != 0:
                        razon = errores[i] / (errores[i-1]**2 / errores[i-2])
                        razones_cuadraticas.append(razon)
                
                if razones_cuadraticas:
                    razon_promedio = sum(razones_cuadraticas) / len(razones_cuadraticas)
                    console.print(f"Factor de convergencia cuadr√°tica: {razon_promedio:.4f}")
                    
                    if razon_promedio < 10:
                        console.print("[green]‚úÖ Convergencia cuadr√°tica confirmada[/green]")
                    else:
                        console.print("[yellow]‚ö†Ô∏è  Convergencia no claramente cuadr√°tica[/yellow]")
        
        # Mostrar tabla completa de resultados
        console.print("\n[bold blue]üìã Tabla Completa de Iteraciones:[/bold blue]")
        
        tabla_completa = Table(title="Resultados Completos")
        tabla_completa.add_column("n", justify="center", style="cyan")
        tabla_completa.add_column("x‚Çô", justify="center", style="green")
        tabla_completa.add_column("f(x‚Çô)", justify="center", style="yellow")
        tabla_completa.add_column("f'(x‚Çô)", justify="center", style="blue")
        tabla_completa.add_column("x‚Çô‚Çä‚ÇÅ", justify="center", style="magenta")
        tabla_completa.add_column("Error", justify="center", style="red")
        
        for r in self.resultados:
            tabla_completa.add_row(
                str(r['iteracion']),
                f"{r['x']:.8f}",
                f"{r['f_x']:.2e}",
                f"{r['df_x']:.2e}",
                f"{r['x_siguiente']:.8f}",
                f"{r['error']:.2e}"
            )
        
        console.print(tabla_completa)
        input("\nPresione Enter para continuar...")
    
    def analisis_convergencia(self):
        """Muestra an√°lisis gr√°fico de convergencia"""
        if not self.resultados:
            console.print("[red]‚ùå No hay resultados disponibles.[/red]")
            input("Presione Enter para continuar...")
            return
        
        # Extraer datos para gr√°ficos
        iteraciones = [r['iteracion'] for r in self.resultados]
        valores_x = [r['x'] for r in self.resultados]
        valores_f = [abs(r['f_x']) for r in self.resultados]
        errores = [r['error'] for r in self.resultados[1:]]
        
        # Crear figura con subplots
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 10))
        fig.suptitle(f'An√°lisis de Convergencia - Newton-Raphson\nf(x) = {self.funcion_str}', fontsize=14)
        
        # 1. Convergencia de x
        ax1.plot(iteraciones, valores_x, 'b-o', markersize=6, linewidth=2)
        ax1.set_xlabel('Iteraci√≥n')
        ax1.set_ylabel('Valor de x')
        ax1.set_title('Convergencia de la Soluci√≥n')
        ax1.grid(True, alpha=0.3)
        
        # L√≠nea horizontal en la soluci√≥n final
        if self.resultados:
            ax1.axhline(y=self.resultados[-1]['x_siguiente'], color='red', linestyle='--', alpha=0.7, label='Soluci√≥n final')
            ax1.legend()
        
        # 2. Error absoluto (escala logar√≠tmica)
        if errores:
            ax2.semilogy(range(1, len(errores)+1), errores, 'r-o', markersize=6, linewidth=2)
            ax2.set_xlabel('Iteraci√≥n')
            ax2.set_ylabel('Error |x‚Çô‚Çä‚ÇÅ - x‚Çô|')
            ax2.set_title('Evoluci√≥n del Error (Escala Log)')
            ax2.grid(True, alpha=0.3)
        
        # 3. Valores de funci√≥n |f(x)|
        ax3.semilogy(iteraciones, valores_f, 'g-o', markersize=6, linewidth=2)
        ax3.set_xlabel('Iteraci√≥n')
        ax3.set_ylabel('|f(x)|')
        ax3.set_title('Convergencia a Cero de f(x)')
        ax3.grid(True, alpha=0.3)
        
        # 4. Visualizaci√≥n geom√©trica del m√©todo
        if len(valores_x) > 1 and self.funcion_numpy:
            try:
                x_min = min(valores_x) - 1
                x_max = max(valores_x) + 1
                x_plot = np.linspace(x_min, x_max, 1000)
                y_plot = [self.funcion_numpy(x) for x in x_plot]
                
                ax4.plot(x_plot, y_plot, 'b-', linewidth=2, label='f(x)')
                ax4.axhline(y=0, color='k', linestyle='--', alpha=0.5)
                
                # Mostrar las primeras iteraciones geom√©tricamente
                for i in range(min(len(self.resultados), 5)):
                    r = self.resultados[i]
                    x_curr = r['x']
                    f_curr = r['f_x']
                    df_curr = r['df_x']
                    
                    # Punto en la curva
                    ax4.plot(x_curr, f_curr, 'ro', markersize=8)
                    
                    # L√≠nea tangente
                    if abs(df_curr) > 1e-10:
                        y_tangent = f_curr + df_curr * (x_plot - x_curr)
                        mask = (x_plot >= x_curr - 0.5) & (x_plot <= x_curr + 0.5)
                        ax4.plot(x_plot[mask], y_tangent[mask], 'r--', alpha=0.7)
                    
                    # L√≠nea vertical hasta eje x
                    x_next = r['x_siguiente']
                    ax4.plot([x_next, x_next], [0, 0], 'go', markersize=6)
                    ax4.plot([x_next, x_next], [0, -max(abs(min(y_plot)), abs(max(y_plot)))*0.1], 'g--', alpha=0.5)
                
                ax4.set_xlabel('x')
                ax4.set_ylabel('f(x)')
                ax4.set_title('Interpretaci√≥n Geom√©trica')
                ax4.legend()
                ax4.grid(True, alpha=0.3)
                
            except Exception as e:
                ax4.text(0.5, 0.5, f'Error al generar gr√°fico:\n{str(e)}', 
                        ha='center', va='center', transform=ax4.transAxes)
        
        plt.tight_layout()
        plt.show()
        
        input("\nPresione Enter para continuar...")
    
    def analisis_derivada(self):
        """Analiza el comportamiento de la derivada"""
        if not self.derivada_numpy:
            console.print("[red]‚ùå No hay derivada configurada.[/red]")
            input("Presione Enter para continuar...")
            return
        
        self.limpiar_pantalla()
        console.print("[bold blue]üîç AN√ÅLISIS DE DERIVADA[/bold blue]\n")
        
        if self.resultados:
            # Mostrar comportamiento de la derivada durante las iteraciones
            console.print("[bold blue]Comportamiento de f'(x) durante iteraciones:[/bold blue]")
            
            deriv_table = Table(title="Valores de f'(x)")
            deriv_table.add_column("Iteraci√≥n", justify="center", style="cyan")
            deriv_table.add_column("x", justify="center", style="green")
            deriv_table.add_column("f'(x)", justify="center", style="yellow")
            deriv_table.add_column("1/f'(x)", justify="center", style="blue")
            deriv_table.add_column("Estado", justify="center", style="red")
            
            for r in self.resultados[:10]:  # Mostrar primeras 10
                df_x = r['df_x']
                estado = "Normal"
                
                if abs(df_x) < 1e-10:
                    estado = "‚ö†Ô∏è Muy peque√±a"
                elif abs(df_x) < 1e-6:
                    estado = "‚ö†Ô∏è Peque√±a"
                elif abs(df_x) > 1e6:
                    estado = "‚ö†Ô∏è Muy grande"
                
                inv_df = 1/df_x if abs(df_x) > 1e-15 else "‚àû"
                
                deriv_table.add_row(
                    str(r['iteracion']),
                    f"{r['x']:.6f}",
                    f"{df_x:.2e}",
                    f"{inv_df:.2e}" if isinstance(inv_df, float) else inv_df,
                    estado
                )
            
            console.print(deriv_table)
        
        # Gr√°fico de funci√≥n y derivada
        if self.funcion_numpy:
            try:
                console.print("\n[green]Generando gr√°fico de funci√≥n y derivada...[/green]")
                
                # Determinar rango para el gr√°fico
                if self.resultados:
                    center = self.resultados[-1]['x_siguiente']
                    span = 2
                else:
                    center = self.x0
                    span = 5
                
                x_plot = np.linspace(center - span, center + span, 1000)
                
                try:
                    y_plot = [self.funcion_numpy(x) for x in x_plot]
                    dy_plot = [self.derivada_numpy(x) for x in x_plot]
                    
                    fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 10))
                    fig.suptitle(f'An√°lisis de f(x) y f\'(x)\nf(x) = {self.funcion_str}', fontsize=14)
                    
                    # Gr√°fico de la funci√≥n
                    ax1.plot(x_plot, y_plot, 'b-', linewidth=2, label='f(x)')
                    ax1.axhline(y=0, color='k', linestyle='--', alpha=0.5)
                    ax1.set_xlabel('x')
                    ax1.set_ylabel('f(x)')
                    ax1.set_title('Funci√≥n f(x)')
                    ax1.legend()
                    ax1.grid(True, alpha=0.3)
                    
                    # Marcar puntos de las iteraciones
                    if self.resultados:
                        x_iteraciones = [r['x'] for r in self.resultados]
                        y_iteraciones = [r['f_x'] for r in self.resultados]
                        ax1.plot(x_iteraciones, y_iteraciones, 'ro', markersize=6, label='Iteraciones')
                        ax1.legend()
                    
                    # Gr√°fico de la derivada
                    ax2.plot(x_plot, dy_plot, 'r-', linewidth=2, label="f'(x)")
                    ax2.axhline(y=0, color='k', linestyle='--', alpha=0.5)
                    ax2.set_xlabel('x')
                    ax2.set_ylabel("f'(x)")
                    ax2.set_title("Derivada f'(x)")
                    ax2.legend()
                    ax2.grid(True, alpha=0.3)
                    
                    # Marcar puntos donde f'(x) ‚âà 0
                    zeros_df = []
                    for i in range(len(dy_plot)-1):
                        if dy_plot[i] * dy_plot[i+1] < 0:  # Cambio de signo
                            x_zero = x_plot[i] + (x_plot[i+1] - x_plot[i]) * (-dy_plot[i]) / (dy_plot[i+1] - dy_plot[i])
                            zeros_df.append(x_zero)
                    
                    if zeros_df:
                        ax2.plot(zeros_df, [0]*len(zeros_df), 'ro', markersize=8, label="f'(x) ‚âà 0")
                        ax2.legend()
                        console.print(f"\n[yellow]‚ö†Ô∏è f'(x) ‚âà 0 en x ‚âà {zeros_df}[/yellow]")
                        console.print("[yellow]Newton-Raphson puede fallar cerca de estos puntos[/yellow]")
                    
                    plt.tight_layout()
                    plt.show()
                    
                except Exception as e:
                    console.print(f"[red]Error al generar gr√°fico: {e}[/red]")
                    
            except Exception as e:
                console.print(f"[red]Error en an√°lisis gr√°fico: {e}[/red]")
        
        input("\nPresione Enter para continuar...")
    
    def mostrar_ayuda(self):
        """Muestra informaci√≥n de ayuda del m√©todo"""
        self.limpiar_pantalla()
        
        ayuda_texto = Panel(
            """
[bold blue]‚ö° M√âTODO DE NEWTON-RAPHSON[/bold blue]

[bold green]¬øQu√© hace?[/bold green]
Encuentra ra√≠ces de f(x) = 0 usando aproximaci√≥n tangente con convergencia cuadr√°tica.

[bold yellow]Algoritmo:[/bold yellow]
1. Calcular f(x) y f'(x)
2. Elegir valor inicial x‚ÇÄ
3. Iterar: x‚Çô‚Çä‚ÇÅ = x‚Çô - f(x‚Çô)/f'(x‚Çô)
4. Parar cuando |x‚Çô‚Çä‚ÇÅ - x‚Çô| < tolerancia

[bold cyan]Ventajas:[/bold cyan]
‚Ä¢ Convergencia cuadr√°tica (muy r√°pida)
‚Ä¢ Alta precisi√≥n alcanzable
‚Ä¢ Funciona bien cerca de ra√≠ces simples

[bold red]Desventajas:[/bold red]
‚Ä¢ Requiere calcular f'(x)
‚Ä¢ Puede diverger si x‚ÇÄ est√° mal elegido
‚Ä¢ Falla cuando f'(x) = 0

[bold magenta]Casos problem√°ticos:[/bold magenta]
‚Ä¢ f'(x) = 0 en la ra√≠z (ra√≠ces m√∫ltiples)
‚Ä¢ f'(x) muy peque√±a cerca de x‚ÇÄ
‚Ä¢ Funciones con comportamiento oscilatorio

[bold white]Consejos pr√°cticos:[/bold white]
‚Ä¢ Use gr√°ficos para elegir x‚ÇÄ
‚Ä¢ Combine con bisecci√≥n si diverge
‚Ä¢ Verifique que f'(x) ‚â† 0 cerca de la ra√≠z
‚Ä¢ Para ra√≠ces m√∫ltiples use m√©todos modificados
            """,
            title="üìö Ayuda - M√©todo de Newton-Raphson",
            border_style="blue"
        )
        
        console.print(ayuda_texto)
        input("\nPresione Enter para continuar...")

def main():
    """Funci√≥n principal"""
    metodo = MetodoNewtonRaphson()
    
    while True:
        opcion = metodo.mostrar_menu_principal()
        
        if opcion == "1":
            metodo.ingresar_funcion()
        elif opcion == "2":
            metodo.configurar_derivada()
        elif opcion == "3":
            metodo.configurar_valor_inicial()
        elif opcion == "4":
            metodo.configurar_parametros()
        elif opcion == "5":
            metodo.ejecutar_metodo()
        elif opcion == "6":
            metodo.ver_resultados()
        elif opcion == "7":
            metodo.analisis_convergencia()
        elif opcion == "8":
            metodo.analisis_derivada()
        elif opcion == "9":
            metodo.mostrar_ayuda()
        elif opcion == "10":
            console.print("\n[bold green]¬°Gracias por usar Newton-Raphson![/bold green]")
            break
        else:
            console.print("[red]Opci√≥n inv√°lida. Seleccione un n√∫mero del 1 al 10.[/red]")
            input("Presione Enter para continuar...")

if __name__ == "__main__":
    main()
```

# Interfaz de Usuario

## Flujo de Men√∫s

El programa presenta un men√∫ principal numerado con opciones completas:

1. **üéØ Ingresar funci√≥n f(x)**: Define la ecuaci√≥n a resolver
2. **üìê Configurar derivada f'(x)**: Simb√≥lica, manual o num√©rica
3. **üìç Configurar valor inicial x‚ÇÄ**: Punto de partida crucial
4. **‚öôÔ∏è Configurar par√°metros**: Tolerancia e iteraciones m√°ximas
5. **üöÄ Ejecutar Newton-Raphson**: Ejecuta el algoritmo completo
6. **üìä Ver resultados**: An√°lisis detallado de la soluci√≥n
7. **üìà An√°lisis de convergencia**: Gr√°ficos de comportamiento
8. **üîç An√°lisis de derivada**: Comportamiento de f'(x)
9. **‚ùì Ayuda**: Informaci√≥n completa del m√©todo
10. **üö™ Salir**: Termina el programa

## Caracter√≠sticas Avanzadas

- **Tres m√©todos para derivada**: Simb√≥lica autom√°tica, manual, o num√©rica
- **Validaci√≥n inteligente**: Detecta problemas potenciales antes de ejecutar
- **An√°lisis geom√©trico**: Visualizaci√≥n de l√≠neas tangentes
- **Detecci√≥n de convergencia cuadr√°tica**: Verificaci√≥n matem√°tica
- **Manejo robusto de errores**: Casos edge y situaciones problem√°ticas

# Ejemplos de Ejecuci√≥n

## Ejemplo 1: Ecuaci√≥n Polinomial

**Problema**: Resolver $x^3 - 2x - 5 = 0$

```
Funci√≥n: f(x) = x**3 - 2*x - 5
Derivada: f'(x) = 3*x**2 - 2
Valor inicial: x‚ÇÄ = 2.0
Tolerancia: 1e-10

Resultados:
n | x‚Çô        | f(x‚Çô)      | f'(x‚Çô)     | x‚Çô‚Çä‚ÇÅ      | Error
0 | 2.00000000| -1.000e+00 | 1.000e+01  | 2.10000000| 1.00e-01
1 | 2.10000000| 2.610e-01  | 1.123e+01  | 2.07675906| 2.32e-02
2 | 2.07675906| 8.788e-03  | 1.094e+01  | 2.07455064| 2.21e-04
3 | 2.07455064| 1.004e-05  | 1.093e+01  | 2.07455064| 9.19e-10

¬°Convergencia alcanzada en 4 iteraciones!
Ra√≠z: x* ‚âà 2.074550644827
f(x*) ‚âà -1.78e-15
```

## Ejemplo 2: Ecuaci√≥n Transcendental

**Problema**: Resolver $e^x - 3x = 0$

```
Funci√≥n: f(x) = exp(x) - 3*x
Derivada: f'(x) = exp(x) - 3
Valor inicial: x‚ÇÄ = 1.5
Tolerancia: 1e-12

Resultados:
n | x‚Çô         | f(x‚Çô)      | f'(x‚Çô)     | x‚Çô‚Çä‚ÇÅ       | Error
0 | 1.50000000 | 0.000e+00  | 1.482e+00  | 1.61912225 | 1.19e-01
1 | 1.61912225 | 5.424e-02  | 2.048e+00  | 1.59263964 | 2.65e-02
2 | 1.59263964 | 1.063e-03  | 1.920e+00  | 1.59210537 | 5.54e-04
3 | 1.59210537 | 4.134e-07  | 1.918e+00  | 1.59210321 | 2.16e-06

¬°Convergencia alcanzada en 4 iteraciones!
Ra√≠z: x* ‚âà 1.592103212165
```

# Visualizaciones

## Gr√°ficos Generados

1. **Convergencia de la soluci√≥n**: Evoluci√≥n de $x_n$ mostrando convergencia r√°pida
2. **Error absoluto**: Decrecimiento cuadr√°tico del error
3. **Convergencia de f(x)**: C√≥mo $|f(x_n)| \to 0$
4. **Interpretaci√≥n geom√©trica**: L√≠neas tangentes y aproximaciones sucesivas
5. **An√°lisis de derivada**: Comportamiento de $f'(x)$ y detecci√≥n de problemas

## Interpretaci√≥n Visual

- **L√≠neas tangentes**: Muestran c√≥mo cada iteraci√≥n usa la pendiente local
- **Convergencia cuadr√°tica**: Error decrece como $error_{n+1} \approx C \cdot error_n^2$
- **Problemas de derivada**: Visualizaci√≥n de puntos donde $f'(x) = 0$

# Ideas de Mejora

## Optimizaciones T√©cnicas

1. **Newton-Raphson modificado**: Para ra√≠ces m√∫ltiples
2. **M√©todo de Halley**: Convergencia c√∫bica usando segunda derivada
3. **Newton-Raphson amortiguado**: Control de paso para mejorar convergencia
4. **Deflaci√≥n autom√°tica**: Para encontrar m√∫ltiples ra√≠ces
5. **M√©todo h√≠brido**: Combinar con bisecci√≥n para robustez

## Funcionalidades Adicionales

1. **Estimaci√≥n autom√°tica de x‚ÇÄ**: Usar gr√°ficos y an√°lisis de signos
2. **Detecci√≥n de ra√≠ces m√∫ltiples**: An√°lisis de multiplicidad
3. **Regi√≥n de convergencia**: Mapeo de valores iniciales exitosos
4. **Comparaci√≥n con otros m√©todos**: Bisecci√≥n, punto fijo, etc.
5. **Modo de producci√≥n**: Procesamiento batch de m√∫ltiples ecuaciones

## Mejoras en An√°lisis

1. **An√°lisis de estabilidad**: Predicci√≥n de convergencia
2. **Optimizaci√≥n de tolerancia**: Sugerencias basadas en precisi√≥n requerida
3. **Detecci√≥n de ciclos**: Identificar convergencia a √≥rbitas peri√≥dicas
4. **An√°lisis de sensibilidad**: Efecto de perturbaciones en x‚ÇÄ

# Complicaciones Encontradas

## Desaf√≠os de Implementaci√≥n

### 1. Manejo de Derivadas
**Problema**: Diferentes formas de calcular f'(x) con precisi√≥n y robustez

**Soluciones implementadas**:
- **Simb√≥lica**: Usando SymPy para exactitud matem√°tica
- **Manual**: Permitir al usuario ingresar la derivada conocida  
- **Num√©rica**: Diferencias finitas con manejo de errores
- **Validaci√≥n cruzada**: Comparar m√©todos cuando es posible

### 2. Detecci√≥n de Problemas de Convergencia
**Problema**: Identificar cu√°ndo el m√©todo fallar√° antes de que ocurra

**Casos identificados**:
- $f'(x) = 0$ en puntos de iteraci√≥n
- $f'(x)$ muy peque√±a (convergencia lenta)
- Divergencia hacia $\pm\infty$
- Convergencia a ciclos en lugar de puntos fijos

**Soluciones**:
- Verificaci√≥n previa de $f'(x_0)$
- L√≠mites en el crecimiento de $|x_n|$
- Detecci√≥n de oscilaciones
- Advertencias proactivas al usuario

### 3. Precisi√≥n Num√©rica
**Problema**: Mantener precisi√≥n en c√°lculos con n√∫meros muy peque√±os/grandes

**Soluciones**:
- Uso de tolerancias adaptativas
- Verificaci√≥n de overflow/underflow
- Escalado autom√°tico para n√∫meros extremos
- Validaci√≥n de resultados finales

### 4. Casos Edge Espec√≠ficos
**Problema**: Situaciones especiales que requieren manejo dedicado

#### a) Ra√≠ces M√∫ltiples
- **Problema**: Convergencia lineal en lugar de cuadr√°tica
- **Detecci√≥n**: An√°lisis de $f'(x)$ cerca de la ra√≠z
- **Soluci√≥n**: Sugerir m√©todos modificados

#### b) Funciones con Discontinuidades
- **Problema**: Evaluaciones fallidas en puntos espec√≠ficos
- **Soluci√≥n**: Manejo robusto de excepciones y saltos adaptativos

#### c) Comportamiento Oscilatorio
- **Problema**: El m√©todo puede "saltar" entre regiones
- **Soluci√≥n**: Detecci√≥n de patrones y amortiguamiento

### 5. Interfaz de Usuario Intuitiva
**Problema**: Hacer comprensible un m√©todo matem√°ticamente sofisticado

**Soluciones**:
- Visualizaci√≥n geom√©trica del proceso
- Explicaciones paso a paso
- Detecci√≥n y explicaci√≥n de problemas comunes
- Sugerencias contextuales basadas en el comportamiento observado

## Lecciones Aprendidas

1. **Validaci√≥n es crucial**: Verificar todas las condiciones antes de ejecutar
2. **Feedback visual ayuda**: Los gr√°ficos clarifican conceptos abstractos
3. **Manejo de errores robusto**: Anticipar y manejar graciosamente los fallos
4. **Documentaci√≥n contextual**: Explicar no solo qu√© hace sino por qu√© puede fallar

# Manual de Uso

## Instalaci√≥n y Requisitos

```bash
# Instalar dependencias
pip install numpy matplotlib rich sympy

# Ejecutar el programa
python newton_raphson.py
```

## Gu√≠a Paso a Paso

### Paso 1: Preparaci√≥n de la Ecuaci√≥n
1. **Identificar la ecuaci√≥n**: Tener $f(x) = 0$ bien definida
2. **Conocer la derivada**: Idealmente tener $f'(x)$ anal√≠ticamente
3. **Estimar ubicaci√≥n de ra√≠ces**: Usar gr√°ficos o an√°lisis de signos

### Paso 2: Configuraci√≥n Inicial
1. **Ingresar funci√≥n** (opci√≥n 1): Usar sintaxis Python est√°ndar
2. **Configurar derivada** (opci√≥n 2): Elegir m√©todo m√°s apropiado
3. **Valor inicial** (opci√≥n 3): Cr√≠tico para convergencia
4. **Par√°metros** (opci√≥n 4): Ajustar tolerancia seg√∫n precisi√≥n requerida

### Paso 3: Ejecuci√≥n y An√°lisis
1. **Ejecutar m√©todo** (opci√≥n 5): Observar convergencia en tiempo real
2. **Analizar resultados** (opci√≥n 6): Verificar calidad de la soluci√≥n
3. **Estudiar convergencia** (opci√≥n 7): Confirmar comportamiento cuadr√°tico
4. **Analizar derivada** (opci√≥n 8): Identificar problemas potenciales

### Paso 4: Interpretaci√≥n de Resultados

#### Convergencia Exitosa
- **Pocas iteraciones** (t√≠picamente < 10)
- **Error decrece cuadr√°ticamente**
- **f(x*) ‚âà 0** con alta precisi√≥n

#### Problemas Comunes y Soluciones

| S√≠ntoma | Causa Probable | Soluci√≥n |
|---------|----------------|----------|
| Diverge r√°pidamente | x‚ÇÄ mal elegido | Probar x‚ÇÄ m√°s cerca de la ra√≠z |
| Convergencia lenta | Ra√≠z m√∫ltiple | Usar Newton-Raphson modificado |
| Error "f'(x) ‚âà 0" | Derivada nula | Cambiar x‚ÇÄ o usar otro m√©todo |
| Oscilaciones | Funci√≥n muy curvada | Reducir paso o usar m√©todo h√≠brido |

## Consejos Avanzados

### Elecci√≥n del Valor Inicial
1. **M√©todo gr√°fico**: Plotear f(x) para ver cambios de signo
2. **An√°lisis de derivada**: Evitar regiones donde f'(x) ‚âà 0
3. **Conocimiento del problema**: Usar informaci√≥n f√≠sica/contextual
4. **M√©todo h√≠brido**: Usar bisecci√≥n para localizar, Newton para refinar

### Optimizaci√≥n de Par√°metros
- **Tolerancia**: $10^{-10}$ para la mayor√≠a de aplicaciones cient√≠ficas
- **Iteraciones m√°ximas**: 50 es generalmente suficiente
- **Verificaci√≥n**: Siempre comprobar que f(x*) ‚âà 0

### Casos Especiales
- **Ra√≠ces m√∫ltiples**: Considerar $x_{n+1} = x_n - m \frac{f(x_n)}{f'(x_n)}$ donde m es la multiplicidad
- **Sistemas de ecuaciones**: Extender a m√©todo de Newton-Raphson multivariable
- **Optimizaci√≥n**: Aplicar a f'(x) = 0 para encontrar extremos

---

*Este documento forma parte del proyecto personal de m√©todos num√©ricos desarrollado como material educativo para Ingenier√≠a en Computaci√≥n.*
