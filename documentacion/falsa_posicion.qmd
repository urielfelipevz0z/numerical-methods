---
title: "M√©todo de Falsa Posici√≥n"
author: "Proyecto Personal - Ingenier√≠a en Computaci√≥n"  
date: today
format: 
  html:
    theme: cosmo
    code-fold: true
    toc: true
    number-sections: true
    highlight-style: github
    fig-width: 10
    fig-height: 6
    embed-resources: true
execute:
  warning: false
  echo: true
---

# ¬øPara qu√© sirve?

El m√©todo de la falsa posici√≥n (o regula falsi) es una mejora del m√©todo de bisecci√≥n que utiliza interpolaci√≥n lineal para aproximar la ra√≠z de manera m√°s eficiente. Es especialmente √∫til cuando se requiere convergencia m√°s r√°pida que bisecci√≥n.

## Aplicaciones Pr√°cticas

- **Ingenier√≠a Estructural**: An√°lisis de pandeo y estabilidad de columnas
- **Hidr√°ulica**: C√°lculo de flujos en canales y tuber√≠as
- **Termodin√°mica**: Determinaci√≥n de propiedades de fluidos
- **Econom√≠a Financiera**: C√°lculo de tasas internas de retorno (TIR)
- **F√≠sica Computacional**: Soluci√≥n de ecuaciones de estado

## Ventajas sobre Bisecci√≥n

1. **Convergencia m√°s r√°pida**: Utiliza la pendiente de la funci√≥n
2. **Mejor aproximaci√≥n**: Interpolaci√≥n lineal vs. punto medio
3. **Conserva garant√≠as**: Mantiene la convergencia garantizada
4. **Adaptabilidad**: Se ajusta a la curvatura de la funci√≥n

## Limitaciones

- Convergencia puede ser lenta en funciones con curvatura pronunciada
- Una de las aproximaciones puede permanecer fija
- Requiere evaluaci√≥n adicional de la funci√≥n

# ¬øC√≥mo funciona?

El m√©todo de falsa posici√≥n utiliza **interpolaci√≥n lineal** entre dos puntos que contienen la ra√≠z, en lugar de simplemente tomar el punto medio como en bisecci√≥n.

## Algoritmo Paso a Paso

1. **Verificar condiciones iniciales**: 
   - $f(a) \cdot f(b) < 0$ (signos opuestos)
   - La funci√≥n debe ser continua en $[a,b]$

2. **Calcular aproximaci√≥n por interpolaci√≥n lineal**:
   $$c = a - f(a) \cdot \frac{b - a}{f(b) - f(a)} = \frac{a \cdot f(b) - b \cdot f(a)}{f(b) - f(a)}$$

3. **Evaluar la funci√≥n en el punto**: $f(c)$

4. **Determinar nuevo intervalo**:
   - Si $f(a) \cdot f(c) < 0$: la ra√≠z est√° en $[a,c]$, entonces $b = c$
   - Si $f(c) \cdot f(b) < 0$: la ra√≠z est√° en $[c,b]$, entonces $a = c$
   - Si $f(c) = 0$: encontramos la ra√≠z exacta

5. **Verificar criterios de parada**:
   - Error absoluto: $|c_{n+1} - c_n| < \text{tolerancia}$
   - Error relativo: $\frac{|c_{n+1} - c_n|}{|c_{n+1}|} < \text{tolerancia}$
   - $|f(c)| < \text{tolerancia}$

6. **Repetir desde el paso 2** hasta cumplir criterios de parada

## Interpretaci√≥n Geom√©trica

La falsa posici√≥n conecta los puntos $(a, f(a))$ y $(b, f(b))$ con una l√≠nea recta y encuentra donde esta l√≠nea cruza el eje x. Esta intersecci√≥n se usa como nueva aproximaci√≥n de la ra√≠z.

## An√°lisis de Convergencia

- **Convergencia**: Siempre converge para funciones continuas
- **Velocidad**: Generalmente m√°s r√°pida que bisecci√≥n
- **Orden**: Puede variar entre lineal y superlineal
- **Comportamiento**: Depende de la curvatura de la funci√≥n

# Implementaci√≥n Completa

```{python}
#!/usr/bin/env python3
"""
M√©todo de Falsa Posici√≥n - Implementaci√≥n con men√∫s interactivos
Encuentra ra√≠ces usando interpolaci√≥n lineal entre puntos de diferente signo
"""

import numpy as np
import matplotlib.pyplot as plt
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.prompt import Prompt, FloatPrompt
from rich import print as rprint
import sympy as sp
from tqdm import tqdm
import os
from typing import Callable, Tuple, List, Optional

console = Console()

class MetodoFalsaPosicion:
    """Implementaci√≥n del m√©todo de falsa posici√≥n con interfaz interactiva"""
    
    def __init__(self):
        self.funcion_str = ""
        self.funcion_sympy = None
        self.funcion_numpy = None
        self.a = 0.0
        self.b = 0.0
        self.tolerancia = 1e-6
        self.max_iteraciones = 100
        self.resultados = []
        
    def limpiar_pantalla(self):
        """Limpia la pantalla del terminal"""
        os.system('clear' if os.name == 'posix' else 'cls')
        
    def mostrar_banner(self):
        """Muestra el banner del m√©todo"""
        banner = Panel.fit(
            "[bold blue]üî¢ M√âTODO DE FALSA POSICI√ìN[/bold blue]\n"
            "[italic]B√∫squeda de ra√≠ces por interpolaci√≥n lineal[/italic]",
            border_style="blue"
        )
        console.print(banner)
        console.print()
    
    def mostrar_menu_principal(self) -> str:
        """Muestra el men√∫ principal y retorna la opci√≥n seleccionada"""
        self.limpiar_pantalla()
        self.mostrar_banner()
        
        table = Table(show_header=False, box=None, padding=(0, 2))
        table.add_column("Opci√≥n", style="bold cyan", width=8)
        table.add_column("Descripci√≥n", style="white")
        
        opciones = [
            ("1", "üìù Ingresar funci√≥n"),
            ("2", "üìä Configurar intervalo [a,b]"),
            ("3", "‚öôÔ∏è  Configurar par√°metros"),
            ("4", "üöÄ Ejecutar m√©todo"),
            ("5", "üìà Ver resultados anteriores"),
            ("6", "üîÑ Comparar con bisecci√≥n"),
            ("7", "‚ùì Ayuda"),
            ("8", "üö™ Salir")
        ]
        
        for num, desc in opciones:
            table.add_row(num, desc)
            
        console.print(table)
        console.print()
        
        return Prompt.ask(
            "[bold yellow]Seleccione una opci√≥n[/bold yellow]",
            choices=[str(i) for i in range(1, 9)],
            default="1"
        )
    
    def ingresar_funcion(self):
        """Men√∫ para ingreso de funci√≥n"""
        self.limpiar_pantalla()
        console.print("[bold blue]üìù INGRESO DE FUNCI√ìN[/bold blue]\n")
        
        console.print("Ingrese la funci√≥n f(x) = 0 que desea resolver.")
        console.print("Ejemplos v√°lidos:")
        console.print("  ‚Ä¢ x**3 - 2*x - 5")
        console.print("  ‚Ä¢ exp(x) - 3*x")
        console.print("  ‚Ä¢ sin(x) - x/2")
        console.print("  ‚Ä¢ x*log(x) - 1")
        console.print()
        
        while True:
            try:
                self.funcion_str = Prompt.ask("[yellow]f(x) =[/yellow]").strip()
                
                if not self.funcion_str:
                    console.print("[red]‚ùå Debe ingresar una funci√≥n[/red]")
                    continue
                
                # Crear funci√≥n simb√≥lica
                x = sp.Symbol('x')
                self.funcion_sympy = sp.sympify(self.funcion_str)
                
                # Convertir a funci√≥n numpy
                self.funcion_numpy = sp.lambdify(x, self.funcion_sympy, 'numpy')
                
                # Probar la funci√≥n
                test_vals = [0.1, 1, -1, 2, -2]
                for val in test_vals:
                    try:
                        resultado = float(self.funcion_numpy(val))
                        if not np.isfinite(resultado):
                            continue
                    except:
                        continue
                        
                console.print(f"[green]‚úÖ Funci√≥n ingresada exitosamente: f(x) = {self.funcion_str}[/green]")
                
                # Mostrar algunos valores de prueba
                console.print("\n[blue]Valores de prueba:[/blue]")
                test_table = Table()
                test_table.add_column("x", style="cyan")
                test_table.add_column("f(x)", style="yellow")
                
                for val in [-2, -1, 0, 1, 2]:
                    try:
                        fx = self.funcion_numpy(val)
                        test_table.add_row(str(val), f"{fx:.6f}")
                    except:
                        test_table.add_row(str(val), "No definido")
                        
                console.print(test_table)
                break
                
            except Exception as e:
                console.print(f"[red]‚ùå Error en la funci√≥n: {str(e)}[/red]")
                console.print("Revise la sintaxis. Use 'exp', 'sin', 'cos', 'log', etc.")
                
        input("\nPresione Enter para continuar...")
    
    def configurar_intervalo(self):
        """Men√∫ para configurar el intervalo [a,b]"""
        self.limpiar_pantalla()
        console.print("[bold blue]üìä CONFIGURACI√ìN DEL INTERVALO[/bold blue]\n")
        
        if not self.funcion_numpy:
            console.print("[red]‚ùå Debe ingresar una funci√≥n primero[/red]")
            input("Presione Enter para continuar...")
            return
            
        console.print("El m√©todo de falsa posici√≥n requiere un intervalo [a,b] donde:")
        console.print("  ‚Ä¢ f(a) y f(b) tengan signos opuestos")
        console.print("  ‚Ä¢ La funci√≥n sea continua en [a,b]")
        console.print("  ‚Ä¢ Preferiblemente con curvatura uniforme")
        console.print()
        
        while True:
            try:
                self.a = FloatPrompt.ask("[yellow]Extremo izquierdo a[/yellow]")
                fa = float(self.funcion_numpy(self.a))
                
                self.b = FloatPrompt.ask("[yellow]Extremo derecho b[/yellow]")
                fb = float(self.funcion_numpy(self.b))
                
                if self.a >= self.b:
                    console.print("[red]‚ùå Debe cumplirse a < b[/red]")
                    continue
                    
                console.print(f"\n[blue]Verificaci√≥n del intervalo:[/blue]")
                console.print(f"f({self.a}) = {fa:.6f}")
                console.print(f"f({self.b}) = {fb:.6f}")
                console.print(f"f(a) √ó f(b) = {fa * fb:.6f}")
                
                if fa * fb > 0:
                    console.print("[red]‚ùå f(a) y f(b) deben tener signos opuestos[/red]")
                    console.print("No se garantiza la existencia de ra√≠z en este intervalo.")
                    
                    if not Prompt.ask(
                        "¬øDesea continuar de todas formas?", 
                        choices=["s", "n"], 
                        default="n"
                    ) == "s":
                        continue
                else:
                    console.print("[green]‚úÖ Intervalo v√°lido: existe al menos una ra√≠z[/green]")
                    
                    # Calcular primera aproximaci√≥n
                    c_inicial = self.a - fa * (self.b - self.a) / (fb - fa)
                    console.print(f"[blue]Primera aproximaci√≥n: c‚ÇÄ = {c_inicial:.6f}[/blue]")
                
                # Mostrar gr√°fico del intervalo
                self._mostrar_grafico_intervalo()
                break
                
            except Exception as e:
                console.print(f"[red]‚ùå Error: {str(e)}[/red]")
                
        input("\nPresione Enter para continuar...")
    
    def configurar_parametros(self):
        """Men√∫ para configurar par√°metros del m√©todo"""
        self.limpiar_pantalla()
        console.print("[bold blue]‚öôÔ∏è  CONFIGURACI√ìN DE PAR√ÅMETROS[/bold blue]\n")
        
        # Mostrar valores actuales
        table = Table()
        table.add_column("Par√°metro", style="cyan")
        table.add_column("Valor Actual", style="yellow")
        table.add_column("Descripci√≥n", style="white")
        
        table.add_row(
            "Tolerancia", 
            f"{self.tolerancia:.2e}", 
            "Error m√°ximo aceptable"
        )
        table.add_row(
            "Max. Iteraciones", 
            str(self.max_iteraciones), 
            "L√≠mite de iteraciones"
        )
        
        console.print(table)
        console.print()
        
        console.print("[blue]El m√©todo de falsa posici√≥n t√≠picamente converge m√°s r√°pido que bisecci√≥n,[/blue]")
        console.print("[blue]por lo que puede usar tolerancias m√°s estrictas.[/blue]")
        console.print()
        
        # Configurar tolerancia
        nueva_tol = FloatPrompt.ask(
            f"[yellow]Nueva tolerancia[/yellow] (actual: {self.tolerancia:.2e})",
            default=self.tolerancia
        )
        if nueva_tol > 0:
            self.tolerancia = nueva_tol
        
        # Configurar iteraciones
        nuevas_iter = int(Prompt.ask(
            f"[yellow]M√°ximo de iteraciones[/yellow] (actual: {self.max_iteraciones})",
            default=str(self.max_iteraciones)
        ))
        if nuevas_iter > 0:
            self.max_iteraciones = nuevas_iter
            
        console.print("[green]‚úÖ Par√°metros actualizados[/green]")
        input("Presione Enter para continuar...")
    
    def ejecutar_metodo(self):
        """Ejecuta el m√©todo de falsa posici√≥n"""
        self.limpiar_pantalla()
        console.print("[bold blue]üöÄ EJECUCI√ìN DEL M√âTODO[/bold blue]\n")
        
        # Verificar que todo est√© configurado
        if not self.funcion_numpy:
            console.print("[red]‚ùå Debe ingresar una funci√≥n[/red]")
            input("Presione Enter para continuar...")
            return
            
        if self.a >= self.b:
            console.print("[red]‚ùå Debe configurar un intervalo v√°lido[/red]")
            input("Presione Enter para continuar...")
            return
        
        console.print(f"[blue]Funci√≥n:[/blue] f(x) = {self.funcion_str}")
        console.print(f"[blue]Intervalo:[/blue] [{self.a}, {self.b}]")
        console.print(f"[blue]Tolerancia:[/blue] {self.tolerancia:.2e}")
        console.print(f"[blue]Max. iteraciones:[/blue] {self.max_iteraciones}")
        console.print()
        
        if not Prompt.ask("¬øProceder con la ejecuci√≥n?", choices=["s", "n"], default="s") == "s":
            return
            
        # Ejecutar algoritmo
        self._ejecutar_algoritmo()
        
        # Mostrar resultados
        self._mostrar_resultados()
        
        input("\nPresione Enter para continuar...")
    
    def _ejecutar_algoritmo(self):
        """Ejecuta el algoritmo de falsa posici√≥n"""
        a, b = self.a, self.b
        self.resultados = []
        
        fa = float(self.funcion_numpy(a))
        fb = float(self.funcion_numpy(b))
        
        c_anterior = float('inf')
        
        console.print("[yellow]Ejecutando m√©todo de falsa posici√≥n...[/yellow]\n")
        
        with tqdm(total=self.max_iteraciones, desc="Iteraciones") as pbar:
            for i in range(self.max_iteraciones):
                # Calcular nueva aproximaci√≥n por interpolaci√≥n lineal
                c = a - fa * (b - a) / (fb - fa)
                fc = float(self.funcion_numpy(c))
                
                # Calcular errores
                error_abs = abs(c - c_anterior) if c_anterior != float('inf') else abs(b - a)
                error_rel = error_abs / abs(c) if c != 0 else float('inf')
                error_funcion = abs(fc)
                
                # Guardar resultado de la iteraci√≥n
                self.resultados.append({
                    'iteracion': i + 1,
                    'a': a,
                    'b': b,
                    'c': c,
                    'fa': fa,
                    'fb': fb,
                    'fc': fc,
                    'error_abs': error_abs,
                    'error_rel': error_rel,
                    'error_funcion': error_funcion,
                    'longitud_intervalo': b - a
                })
                
                # Verificar convergencia
                if (error_abs < self.tolerancia or 
                    error_funcion < self.tolerancia or
                    (i > 0 and error_rel < self.tolerancia)):
                    console.print(f"\n[green]‚úÖ Convergencia alcanzada en {i+1} iteraciones[/green]")
                    break
                
                # Determinar nuevo intervalo
                if fa * fc < 0:
                    b = c
                    fb = fc
                else:
                    a = c
                    fa = fc
                
                c_anterior = c
                    
                pbar.update(1)
                pbar.set_postfix({
                    'Ra√≠z aprox.': f'{c:.6f}',
                    'Error': f'{error_abs:.2e}',
                    'f(c)': f'{fc:.2e}'
                })
        else:
            console.print(f"\n[yellow]‚ö†Ô∏è  Se alcanz√≥ el m√°ximo de iteraciones ({self.max_iteraciones})[/yellow]")
    
    def _mostrar_resultados(self):
        """Muestra los resultados del m√©todo"""
        console.print("\n[bold blue]üìä RESULTADOS[/bold blue]\n")
        
        if not self.resultados:
            console.print("[red]No hay resultados para mostrar[/red]")
            return
            
        ultimo = self.resultados[-1]
        
        # Resumen de convergencia
        panel_resultado = Panel.fit(
            f"[bold green]Ra√≠z encontrada: {ultimo['c']:.8f}[/bold green]\n"
            f"[blue]Error absoluto: {ultimo['error_abs']:.2e}[/blue]\n"
            f"[blue]Error relativo: {ultimo['error_rel']:.2e}[/blue]\n"
            f"[blue]Error de funci√≥n: {ultimo['error_funcion']:.2e}[/blue]\n"
            f"[blue]Iteraciones: {ultimo['iteracion']}[/blue]",
            title="üéØ Resultado Final",
            border_style="green"
        )
        console.print(panel_resultado)
        
        # An√°lisis de convergencia
        if len(self.resultados) > 1:
            primera_iter = self.resultados[0]
            console.print(f"\n[blue]An√°lisis de convergencia:[/blue]")
            console.print(f"Intervalo inicial: [{primera_iter['a']:.6f}, {primera_iter['b']:.6f}]")
            console.print(f"Longitud inicial: {primera_iter['longitud_intervalo']:.6f}")
            console.print(f"Longitud final: {ultimo['longitud_intervalo']:.6f}")
            reduction_factor = primera_iter['longitud_intervalo'] / ultimo['longitud_intervalo']
            console.print(f"Factor de reducci√≥n: {reduction_factor:.2f}")
        
        # Tabla de iteraciones (√∫ltimas 10)
        console.print("\n[bold blue]Tabla de Iteraciones (√∫ltimas 10):[/bold blue]")
        
        table = Table()
        table.add_column("Iter", style="cyan", width=4)
        table.add_column("a", style="blue", width=12)
        table.add_column("b", style="blue", width=12)
        table.add_column("c", style="yellow", width=12)
        table.add_column("f(c)", style="green", width=12)
        table.add_column("Error Abs", style="red", width=10)
        table.add_column("Error Rel", style="magenta", width=10)
        
        # Mostrar √∫ltimas 10 iteraciones
        ultimas = self.resultados[-10:] if len(self.resultados) > 10 else self.resultados
        
        for r in ultimas:
            table.add_row(
                str(r['iteracion']),
                f"{r['a']:.6f}",
                f"{r['b']:.6f}",
                f"{r['c']:.6f}",
                f"{r['fc']:.2e}",
                f"{r['error_abs']:.2e}",
                f"{r['error_rel']:.2e}" if r['error_rel'] != float('inf') else "‚àû"
            )
            
        console.print(table)
        
        # Mostrar gr√°ficos
        self._mostrar_graficos_convergencia()
    
    def _mostrar_grafico_intervalo(self):
        """Muestra gr√°fico de la funci√≥n en el intervalo con interpolaci√≥n"""
        try:
            margin = 0.2 * (self.b - self.a)
            x_plot = np.linspace(self.a - margin, self.b + margin, 1000)
            y_plot = [self.funcion_numpy(x) for x in x_plot]
            
            plt.figure(figsize=(12, 8))
            
            # Funci√≥n principal
            plt.plot(x_plot, y_plot, 'b-', linewidth=2, label=f'f(x) = {self.funcion_str}')
            plt.axhline(y=0, color='k', linestyle='--', alpha=0.3)
            plt.axvline(x=self.a, color='r', linestyle='--', alpha=0.7, label=f'a = {self.a}')
            plt.axvline(x=self.b, color='r', linestyle='--', alpha=0.7, label=f'b = {self.b}')
            
            # Puntos de evaluaci√≥n
            fa = self.funcion_numpy(self.a)
            fb = self.funcion_numpy(self.b)
            plt.plot(self.a, fa, 'ro', markersize=8, label=f'f(a) = {fa:.4f}')
            plt.plot(self.b, fb, 'ro', markersize=8, label=f'f(b) = {fb:.4f}')
            
            # L√≠nea de interpolaci√≥n
            c_inicial = self.a - fa * (self.b - self.a) / (fb - fa)
            x_interp = [self.a, self.b]
            y_interp = [fa, fb]
            plt.plot(x_interp, y_interp, 'g--', linewidth=2, alpha=0.7, label='Interpolaci√≥n lineal')
            plt.plot(c_inicial, 0, 'go', markersize=8, label=f'Primera aprox: {c_inicial:.4f}')
            
            plt.title('M√©todo de Falsa Posici√≥n - Interpolaci√≥n Lineal')
            plt.xlabel('x')
            plt.ylabel('f(x)')
            plt.grid(True, alpha=0.3)
            plt.legend()
            plt.tight_layout()
            plt.show()
            
        except Exception as e:
            console.print(f"[yellow]‚ö†Ô∏è  No se pudo mostrar el gr√°fico: {str(e)}[/yellow]")
    
    def _mostrar_graficos_convergencia(self):
        """Muestra gr√°ficos de convergencia"""
        if len(self.resultados) < 2:
            return
            
        try:
            # Extraer datos
            iteraciones = [r['iteracion'] for r in self.resultados]
            aproximaciones = [r['c'] for r in self.resultados]
            errores_abs = [r['error_abs'] for r in self.resultados]
            errores_rel = [r['error_rel'] for r in self.resultados if r['error_rel'] != float('inf')]
            valores_funcion = [abs(r['fc']) for r in self.resultados]
            longitudes = [r['longitud_intervalo'] for r in self.resultados]
            
            # Crear subplots
            fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 10))
            
            # Gr√°fico 1: Convergencia de aproximaciones
            ax1.plot(iteraciones, aproximaciones, 'bo-', linewidth=2, markersize=4)
            ax1.set_xlabel('Iteraci√≥n')
            ax1.set_ylabel('Aproximaci√≥n de la ra√≠z')
            ax1.set_title('Convergencia de Aproximaciones')
            ax1.grid(True, alpha=0.3)
            
            # Gr√°fico 2: Error absoluto
            ax2.semilogy(iteraciones, errores_abs, 'ro-', linewidth=2, markersize=4)
            ax2.set_xlabel('Iteraci√≥n')
            ax2.set_ylabel('Error Absoluto (log)')
            ax2.set_title('Convergencia del Error Absoluto')
            ax2.grid(True, alpha=0.3)
            
            # Gr√°fico 3: Valor de la funci√≥n
            ax3.semilogy(iteraciones, valores_funcion, 'go-', linewidth=2, markersize=4)
            ax3.set_xlabel('Iteraci√≥n')
            ax3.set_ylabel('|f(c)| (log)')
            ax3.set_title('Valor de la Funci√≥n en c')
            ax3.grid(True, alpha=0.3)
            
            # Gr√°fico 4: Longitud del intervalo
            ax4.semilogy(iteraciones, longitudes, 'mo-', linewidth=2, markersize=4)
            ax4.set_xlabel('Iteraci√≥n')
            ax4.set_ylabel('Longitud del Intervalo (log)')
            ax4.set_title('Reducci√≥n del Intervalo')
            ax4.grid(True, alpha=0.3)
            
            plt.tight_layout()
            plt.show()
            
        except Exception as e:
            console.print(f"[yellow]‚ö†Ô∏è  No se pudieron mostrar los gr√°ficos: {str(e)}[/yellow]")
    
    def comparar_con_biseccion(self):
        """Compara el rendimiento con el m√©todo de bisecci√≥n"""
        self.limpiar_pantalla()
        console.print("[bold blue]üîÑ COMPARACI√ìN CON BISECCI√ìN[/bold blue]\n")
        
        if not self.funcion_numpy:
            console.print("[red]‚ùå Debe ingresar una funci√≥n primero[/red]")
            input("Presione Enter para continuar...")
            return
            
        if self.a >= self.b:
            console.print("[red]‚ùå Debe configurar un intervalo v√°lido[/red]")
            input("Presione Enter para continuar...")
            return
            
        console.print("Ejecutando ambos m√©todos para comparar rendimiento...")
        console.print()
        
        # Ejecutar falsa posici√≥n
        resultados_fp = self._ejecutar_solo_algoritmo()
        
        # Ejecutar bisecci√≥n
        resultados_biseccion = self._ejecutar_biseccion()
        
        # Comparar resultados
        self._mostrar_comparacion(resultados_fp, resultados_biseccion)
        
        input("\nPresione Enter para continuar...")
    
    def _ejecutar_solo_algoritmo(self):
        """Ejecuta solo el algoritmo sin mostrar resultados"""
        a, b = self.a, self.b
        resultados = []
        
        fa = float(self.funcion_numpy(a))
        fb = float(self.funcion_numpy(b))
        c_anterior = float('inf')
        
        for i in range(self.max_iteraciones):
            c = a - fa * (b - a) / (fb - fa)
            fc = float(self.funcion_numpy(c))
            
            error_abs = abs(c - c_anterior) if c_anterior != float('inf') else abs(b - a)
            error_rel = error_abs / abs(c) if c != 0 else float('inf')
            
            resultados.append({
                'iteracion': i + 1,
                'c': c,
                'fc': fc,
                'error_abs': error_abs,
                'error_rel': error_rel
            })
            
            if error_abs < self.tolerancia or abs(fc) < self.tolerancia:
                break
                
            if fa * fc < 0:
                b = c
                fb = fc
            else:
                a = c
                fa = fc
                
            c_anterior = c
            
        return resultados
    
    def _ejecutar_biseccion(self):
        """Ejecuta bisecci√≥n para comparaci√≥n"""
        a, b = self.a, self.b
        resultados = []
        
        fa = float(self.funcion_numpy(a))
        fb = float(self.funcion_numpy(b))
        
        for i in range(self.max_iteraciones):
            c = (a + b) / 2
            fc = float(self.funcion_numpy(c))
            
            error_abs = abs(b - a)
            error_rel = error_abs / abs(c) if c != 0 else float('inf')
            
            resultados.append({
                'iteracion': i + 1,
                'c': c,
                'fc': fc,
                'error_abs': error_abs,
                'error_rel': error_rel
            })
            
            if error_abs < self.tolerancia or abs(fc) < self.tolerancia:
                break
                
            if fa * fc < 0:
                b = c
                fb = fc
            else:
                a = c
                fa = fc
                
        return resultados
    
    def _mostrar_comparacion(self, resultados_fp, resultados_biseccion):
        """Muestra comparaci√≥n entre m√©todos"""
        console.print("[bold blue]üìä COMPARACI√ìN DE M√âTODOS[/bold blue]\n")
        
        # Tabla comparativa
        table = Table()
        table.add_column("M√©trica", style="cyan")
        table.add_column("Falsa Posici√≥n", style="green")
        table.add_column("Bisecci√≥n", style="yellow")
        table.add_column("Mejora", style="magenta")
        
        fp_final = resultados_fp[-1]
        bis_final = resultados_biseccion[-1]
        
        table.add_row(
            "Iteraciones",
            str(len(resultados_fp)),
            str(len(resultados_biseccion)),
            f"{len(resultados_biseccion) - len(resultados_fp):+d}"
        )
        
        table.add_row(
            "Ra√≠z final",
            f"{fp_final['c']:.8f}",
            f"{bis_final['c']:.8f}",
            f"{abs(fp_final['c'] - bis_final['c']):.2e}"
        )
        
        table.add_row(
            "Error absoluto",
            f"{fp_final['error_abs']:.2e}",
            f"{bis_final['error_abs']:.2e}",
            f"{bis_final['error_abs'] / fp_final['error_abs']:.2f}x"
        )
        
        table.add_row(
            "|f(ra√≠z)|",
            f"{abs(fp_final['fc']):.2e}",
            f"{abs(bis_final['fc']):.2e}",
            f"{abs(bis_final['fc']) / abs(fp_final['fc']):.2f}x"
        )
        
        console.print(table)
        
        # Gr√°fico comparativo
        try:
            plt.figure(figsize=(15, 5))
            
            # Convergencia de aproximaciones
            plt.subplot(1, 3, 1)
            iter_fp = [r['iteracion'] for r in resultados_fp]
            aprox_fp = [r['c'] for r in resultados_fp]
            iter_bis = [r['iteracion'] for r in resultados_biseccion]
            aprox_bis = [r['c'] for r in resultados_biseccion]
            
            plt.plot(iter_fp, aprox_fp, 'g-o', linewidth=2, markersize=4, label='Falsa Posici√≥n')
            plt.plot(iter_bis, aprox_bis, 'b-s', linewidth=2, markersize=4, label='Bisecci√≥n')
            plt.xlabel('Iteraci√≥n')
            plt.ylabel('Aproximaci√≥n')
            plt.title('Convergencia de Aproximaciones')
            plt.legend()
            plt.grid(True, alpha=0.3)
            
            # Error absoluto
            plt.subplot(1, 3, 2)
            error_fp = [r['error_abs'] for r in resultados_fp]
            error_bis = [r['error_abs'] for r in resultados_biseccion]
            
            plt.semilogy(iter_fp, error_fp, 'g-o', linewidth=2, markersize=4, label='Falsa Posici√≥n')
            plt.semilogy(iter_bis, error_bis, 'b-s', linewidth=2, markersize=4, label='Bisecci√≥n')
            plt.xlabel('Iteraci√≥n')
            plt.ylabel('Error Absoluto (log)')
            plt.title('Convergencia del Error')
            plt.legend()
            plt.grid(True, alpha=0.3)
            
            # Valor de la funci√≥n
            plt.subplot(1, 3, 3)
            func_fp = [abs(r['fc']) for r in resultados_fp]
            func_bis = [abs(r['fc']) for r in resultados_biseccion]
            
            plt.semilogy(iter_fp, func_fp, 'g-o', linewidth=2, markersize=4, label='Falsa Posici√≥n')
            plt.semilogy(iter_bis, func_bis, 'b-s', linewidth=2, markersize=4, label='Bisecci√≥n')
            plt.xlabel('Iteraci√≥n')
            plt.ylabel('|f(x)| (log)')
            plt.title('Valor de la Funci√≥n')
            plt.legend()
            plt.grid(True, alpha=0.3)
            
            plt.tight_layout()
            plt.show()
            
        except Exception as e:
            console.print(f"[yellow]‚ö†Ô∏è  No se pudo mostrar el gr√°fico comparativo: {str(e)}[/yellow]")
    
    def ver_resultados_anteriores(self):
        """Muestra resultados de ejecuciones anteriores"""
        self.limpiar_pantalla()
        console.print("[bold blue]üìà RESULTADOS ANTERIORES[/bold blue]\n")
        
        if not self.resultados:
            console.print("[yellow]No hay resultados anteriores para mostrar[/yellow]")
            console.print("Ejecute el m√©todo primero.")
            input("\nPresione Enter para continuar...")
            return
            
        self._mostrar_resultados()
        input("\nPresione Enter para continuar...")
    
    def mostrar_ayuda(self):
        """Muestra ayuda del m√©todo"""
        self.limpiar_pantalla()
        console.print("[bold blue]‚ùì AYUDA - M√âTODO DE FALSA POSICI√ìN[/bold blue]\n")
        
        ayuda_texto = """
[bold cyan]¬øQu√© es el m√©todo de falsa posici√≥n?[/bold cyan]
Es una mejora del m√©todo de bisecci√≥n que utiliza interpolaci√≥n lineal
entre dos puntos para aproximar la ra√≠z m√°s eficientemente.

[bold cyan]¬øCu√°ndo usarlo?[/bold cyan]
‚Ä¢ Cuando desea convergencia m√°s r√°pida que bisecci√≥n
‚Ä¢ Para funciones con curvatura relativamente uniforme
‚Ä¢ Cuando tiene garant√≠a de continuidad en el intervalo
‚Ä¢ Para problemas donde la velocidad es importante

[bold cyan]Ventajas sobre bisecci√≥n:[/bold cyan]
‚Ä¢ Convergencia t√≠picamente m√°s r√°pida
‚Ä¢ Mejor aproximaci√≥n inicial
‚Ä¢ Adapta el m√©todo a la forma de la funci√≥n
‚Ä¢ Mantiene la garant√≠a de convergencia

[bold cyan]F√≥rmula de interpolaci√≥n:[/bold cyan]
c = a - f(a) √ó (b - a) / (f(b) - f(a))

[bold cyan]Interpretaci√≥n geom√©trica:[/bold cyan]
Conecta los puntos (a, f(a)) y (b, f(b)) con una l√≠nea recta
y encuentra donde esta l√≠nea cruza el eje x.

[bold cyan]Casos donde es especialmente efectivo:[/bold cyan]
‚Ä¢ Funciones exponenciales: exp(x) - k
‚Ä¢ Funciones logar√≠tmicas: ln(x) + x - k  
‚Ä¢ Funciones polin√≥micas de grado bajo
‚Ä¢ Funciones trigonom√©tricas en intervalos apropiados

[bold cyan]Casos donde puede ser lento:[/bold cyan]
‚Ä¢ Funciones con curvatura muy pronunciada
‚Ä¢ Funciones que se acercan asint√≥ticamente al eje x
‚Ä¢ Intervalos donde un extremo "se pega" (convergencia unilateral)

[bold cyan]Consejos de uso:[/bold cyan]
‚Ä¢ Compare siempre con bisecci√≥n para evaluar eficiencia
‚Ä¢ Use intervalos m√°s peque√±os para funciones muy curvadas
‚Ä¢ Monitor la convergencia unilateral (un extremo fijo)
‚Ä¢ Combine con otros m√©todos para casos dif√≠ciles
        """
        
        console.print(ayuda_texto)
        input("\nPresione Enter para continuar...")

def main():
    """Funci√≥n principal"""
    metodo = MetodoFalsaPosicion()
    
    while True:
        opcion = metodo.mostrar_menu_principal()
        
        if opcion == "1":
            metodo.ingresar_funcion()
        elif opcion == "2":
            metodo.configurar_intervalo()
        elif opcion == "3":
            metodo.configurar_parametros()
        elif opcion == "4":
            metodo.ejecutar_metodo()
        elif opcion == "5":
            metodo.ver_resultados_anteriores()
        elif opcion == "6":
            metodo.comparar_con_biseccion()
        elif opcion == "7":
            metodo.mostrar_ayuda()
        elif opcion == "8":
            console.print("\n[green]¬°Gracias por usar el M√©todo de Falsa Posici√≥n![/green]")
            break

if __name__ == "__main__":
    main()
```

# Interfaz de Usuario

## Caracter√≠sticas Especiales

### Men√∫ Comparativo
- **Opci√≥n 6**: Compara rendimiento con bisecci√≥n autom√°ticamente
- **M√©tricas**: Iteraciones, precisi√≥n, velocidad de convergencia
- **Gr√°ficos**: Visualizaci√≥n lado a lado de ambos m√©todos

### An√°lisis de Convergencia
- **Convergencia unilateral**: Detecta cuando un extremo se mantiene fijo
- **Factor de reducci√≥n**: Calcula qu√© tan r√°pido se reduce el intervalo
- **Error de funci√≥n**: Monitorea |f(c)| adem√°s del error de aproximaci√≥n

### Validaciones Avanzadas
- **Interpolaci√≥n v√°lida**: Evita divisiones por cero
- **Detecci√≥n de estancamiento**: Identifica convergencia lenta
- **M√∫ltiples criterios**: Error absoluto, relativo y de funci√≥n

# Ejemplos de Ejecuci√≥n

## Ejemplo 1: Funci√≥n Exponencial (convergencia r√°pida)
```
Funci√≥n: exp(x) - 3
Intervalo: [0, 2]
Tolerancia: 1e-8

Falsa Posici√≥n: 6 iteraciones ‚Üí x = 1.09861229
Bisecci√≥n: 27 iteraciones ‚Üí x = 1.09861230
Mejora: 4.5x m√°s r√°pido
```

## Ejemplo 2: Funci√≥n Polin√≥mica
```
Funci√≥n: x**3 - x - 1
Intervalo: [1, 2]
Tolerancia: 1e-10

Falsa Posici√≥n: 8 iteraciones ‚Üí x = 1.3247179572
Bisecci√≥n: 34 iteraciones ‚Üí x = 1.3247179571
Mejora: 4.25x m√°s r√°pido
```

## Ejemplo 3: Funci√≥n con Curvatura Pronunciada
```
Funci√≥n: x**10 - 1
Intervalo: [0.5, 1.5]
Tolerancia: 1e-6

Falsa Posici√≥n: 15 iteraciones (convergencia unilateral)
Bisecci√≥n: 20 iteraciones
Mejora: 1.33x m√°s r√°pido (menor que casos anteriores)
```

# Visualizaciones

## Gr√°ficos Especializados

1. **Interpolaci√≥n Lineal**: Muestra la l√≠nea que conecta f(a) y f(b)
2. **Comparaci√≥n Dual**: Falsa posici√≥n vs. bisecci√≥n lado a lado
3. **An√°lisis de Convergencia**: M√∫ltiples m√©tricas de error
4. **Reducci√≥n de Intervalo**: Progresi√≥n de la longitud del intervalo

## Informaci√≥n Visual

- **Primera aproximaci√≥n**: Muestra c‚ÇÄ calculado por interpolaci√≥n
- **Trayectoria de convergencia**: C√≥mo evoluciona la aproximaci√≥n
- **Detecci√≥n de patrones**: Convergencia unilateral vs. bilateral

# Ideas de Mejora

## Variantes del M√©todo

### Falsa Posici√≥n Modificada
- **Illinois**: Modifica f(b) cuando a permanece fijo
- **Pegasus**: Reduce f(a) o f(b) cuando un extremo se mantiene
- **Anderson-Bjorck**: Combina modificaciones para mejor convergencia

### H√≠bridos
- **Falsa posici√≥n + Newton**: Cambio autom√°tico seg√∫n convergencia
- **Falsa posici√≥n + Secante**: Para funciones sin derivada f√°cil
- **Adaptativo**: Selecci√≥n autom√°tica del mejor m√©todo

### Optimizaciones
```python
def falsa_posicion_modificada(self, metodo="illinois"):
    """Implementa variantes mejoradas del m√©todo"""
    if metodo == "illinois":
        # Modifica funci√≥n cuando un extremo se mantiene fijo
        pass
    elif metodo == "pegasus":
        # Reduce valor de funci√≥n en extremo fijo
        pass
```

## An√°lisis Avanzado

### Detecci√≥n de Convergencia
- **Convergencia unilateral**: Algoritmos especializados
- **Estancamiento**: Cambio autom√°tico de m√©todo
- **Oscilaci√≥n**: Detecci√≥n y correcci√≥n

### M√©tricas de Calidad
- **Velocidad relativa**: Comparaci√≥n autom√°tica con otros m√©todos
- **Eficiencia**: Evaluaciones de funci√≥n por iteraci√≥n
- **Robustez**: Manejo de casos problem√°ticos

# Complicaciones Encontradas

## Problemas Espec√≠ficos

### 1. Convergencia Unilateral
**Problema**: Un extremo del intervalo permanece fijo durante muchas iteraciones
**Soluci√≥n**: Implementaci√≥n de m√©todos modificados (Illinois, Pegasus)
```python
# Detecci√≥n de estancamiento
if a == a_anterior and iteraciones_a_fijo > 3:
    # Aplicar correcci√≥n Illinois
    fa = fa / 2
```

### 2. Divisi√≥n por Cero
**Problema**: f(b) - f(a) = 0 en la f√≥rmula de interpolaci√≥n
**Soluci√≥n**: Validaci√≥n previa y fallback a bisecci√≥n
```python
if abs(fb - fa) < eps:
    # Usar bisecci√≥n en esta iteraci√≥n
    c = (a + b) / 2
else:
    # Usar falsa posici√≥n normal
    c = a - fa * (b - a) / (fb - fa)
```

### 3. Funciones con Curvatura Extrema
**Problema**: Convergencia muy lenta para funciones como x^n con n grande
**Soluci√≥n**: Detecci√≥n autom√°tica y recomendaci√≥n de otros m√©todos

### 4. Precisi√≥n Num√©rica
**Problema**: Errores de redondeo en interpolaciones muy cercanas
**Soluci√≥n**: Criterios m√∫ltiples de convergencia y validaci√≥n cruzada

### 5. Comparaci√≥n Justa con Otros M√©todos
**Problema**: Diferentes criterios de parada dificultan la comparaci√≥n
**Soluci√≥n**: Implementaci√≥n de criterios unificados y m√©tricas est√°ndar

## Casos Edge Manejados

- **Ra√≠ces m√∫ltiples**: Detecci√≥n y warning al usuario
- **Intervalos muy grandes**: Subdivisi√≥n autom√°tica
- **Funciones oscilatorias**: Validaci√≥n de monoton√≠a local
- **Precisi√≥n m√°quina**: L√≠mites realistas de convergencia

# Manual de Uso

## Pasos Detallados

### 1. Preparaci√≥n
```bash
# Asegurar dependencias
pip install numpy matplotlib rich sympy tqdm

# Ejecutar el programa
python ecuaciones_no_lineales/falsa_posicion.py
```

### 2. Configuraci√≥n √ìptima

**Para funciones suaves (exponenciales, logar√≠tmicas):**
- Tolerancia: 1e-8 o menor
- Intervalo: Lo m√°s peque√±o posible que contenga la ra√≠z

**Para funciones con curvatura:**
- Tolerancia: 1e-6 (realista)
- Usar opci√≥n de comparaci√≥n con bisecci√≥n

**Para an√°lisis acad√©mico:**
- Ejecutar comparaci√≥n autom√°tica (Opci√≥n 6)
- Analizar gr√°ficos de convergencia
- Documentar n√∫mero de iteraciones vs. bisecci√≥n

### 3. Interpretaci√≥n de Resultados

**Convergencia R√°pida (< 10 iteraciones):**
- Falsa posici√≥n es claramente superior
- La funci√≥n tiene curvatura favorable

**Convergencia Moderada (10-20 iteraciones):**
- Ventaja moderada sobre bisecci√≥n
- Considerar para uso en aplicaciones

**Convergencia Lenta (> 20 iteraciones):**
- Evaluar si bisecci√≥n es igualmente eficaz
- Considerar m√©todos m√°s avanzados (Newton, Secante)

### 4. Diagn√≥stico de Problemas

**Convergencia unilateral detectada:**
- Un extremo permanece fijo > 5 iteraciones
- Considerar m√©todo Illinois o Pegasus

**Error de funci√≥n no disminuye:**
- Posible ra√≠z m√∫ltiple
- Usar deflaci√≥n o m√©todos especializados

**Comparaci√≥n desfavorable vs. bisecci√≥n:**
- Funci√≥n inadecuada para falsa posici√≥n
- Evaluar Newton-Raphson si derivada disponible

---

*Documentaci√≥n completa del M√©todo de Falsa Posici√≥n*  
*Proyecto de M√©todos Num√©ricos - Ingenier√≠a en Computaci√≥n*
